<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack常用插件整理]]></title>
    <url>%2F2017%2F09%2F19%2Fwebpack%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[webpack有很多很好用的插件，它们帮助我们日常的开发效率提高了不少，本篇博客将着重介绍一些通用的插件，适合不同框架的项目使用。 html-webpack-plugin一个项目，不管是多页面应用还是单页面应用，都需要有html页面来承载内容，本来是一件比较容易的事，但是在webpack这个环境下，有些地方会让人觉得不是很舒服。 静态资源路径问题举个最简单的栗子，上次讲解webpack配置的时候也提过，就是开启本地服务器需要配置静态资源目录路径。12contentBase: '/' //默认解析静态资源的路径contentBase: '/src/' //手动指向静态资源目录的路径 这是其中一个麻烦的点，不同项目还得配不同的contentBase参数。 不能跟随js一起打包webpack并没有那么智能会去解index.html的路径，它的设计初衷只是为了打包js而已，也就是如果你在资源目录里创建了一个html文件，webpack并不认识，自然也就不会自动打包到对应的打包目录，单页面还好，多页面的话简直是噩梦，还要自己手动copy页面，每次打包都会清空一次打包目录，意味着要一直重复这种操作，太累了。 页面引用资源的相对路径最绝望的是如果你原来页面写的是相对路径来访问一些静态资源，转到打包目录，结构层次不一样，路径全得改。。。不敢想下去了，大工程啊。 无法便捷的利用缓存机制想有效利用缓存，最方便的就是给引入的文件后缀加hash值或者时间戳，保证该文件的唯一性，这样当浏览器去解析该文件的时候，如果之前下载过，会直接读取缓存，减少一次请求资源的操作。但是每次你改了静态资源的内容，由于你需要更新内容，不得不改变对应的hash值，然后你需要自己手动改。。太麻烦了，这样一点都不自动化。 html-webpack-plugin参数简介以上的问题，我们可以通过html-webpack-plugin来进行解决，配置该插件也非常方便，如下： 123456789101112131415new HtmlWebpackPlugin(&#123; //html文件的标题 title: 'My App', //简易压缩html文件的体积，去空格 minify: &#123; collapseWhitespace: true &#125;, //会将hash值添加到每个引入的js和css文件上 hash:true, //允许生成的html页面上引入不同的chunkjs，而不是默认的入口js chunks: ['app', 'libs'], //Webpack需要的模板的路径，用过模板文件的童鞋应该知道是干嘛的 template: SRC_PATH + '/app.ejs', //要写入HTML的文件。默认为index.html。您也可以在这里指定一个子目录（例如：assets / admin.html）。 filename: 'index.html' &#125;), 其他一些具体的参数参考这里，对应的模板文件参考如下写法： 12345678910//app.ejs&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 当然你直接用html文件也是一样的，剩下的html-webpack-plugin会帮你搞定的，享受自动化的构建体验吧！ extract-text-webpack-plugin当我们开发的时候，css-loader和style-loader可以方便的把样式打包进js里面，并以style标签形式内嵌在页面上,这为我们提供了方便，因为是打包进去的，所以也支持webpack的热更新，但在生产环境下就比较尴尬了，具体有以下几个问题： 内嵌的结构不清晰，增大了页面的体积这个问题反映在比较大的项目里，css通常都会比较多，全部挤在一起，也不易维护和调试。由于是内嵌的代码也无法使用sources map，代码的优雅性也大大降低。 无法有效利用缓存机制和CDN给文件后缀加hash或时间戳是利用缓存的常用形式，但这局限于css实体文件，CDN引流资源也是一样，内嵌的形式限制了很多功能的实现。 extract-text-webpack-plugin参数简介为了享受实体css文件的好处，我们选择了这个插件来处理css-loader处理过的css模块，下面贴出常用的一些配置属性： 12345678910new ExtractTextPlugin(&#123; //默认自动生成，id为此插件实例的唯一标识符 id:chunkId, //输出的css文件名，可以包括[name]，[id]和[contenthash] filename: 'css/[name].[contenthash].css', //禁用插件 disable: __DEV__, //从所有附加chunk中提取css文件（默认情况下，它仅从初始块中提取）， 当使用CommonsChunkPlugin并且在commons chunk中有提取的块时，allChunks必须设置为true allChunks: true &#125;) 这样配置只能提取纯css样式，如果我们项目中有用一些css预编译器，比如sass，less，styl等等，光这样还不够，我们还需要配置另一个方法：12345678ExtractTextPlugin.extract(&#123; //当CSS未被提取时应该使用的loader fallback: "style-loader", //将资源通过配置的loader来转换为css（必填，支持预处理器就靠这个参数） use: ['css-loader', 'sass-loader'], //覆盖默认的publicPath设置 publicPath:'/'&#125;); 如果配置顺利的话，最后打包上线在页面上显示的应该就是这个样子：1&lt;link href="css/app.ff056f366d9a3c7632b010597cbcd7ba.css" rel="stylesheet"&gt; 这符合我们的预期，通过配置，我们也可以区别生产和开发环境，这个以后会讨论。]]></content>
      <tags>
        <tag>webpack plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的配置解析]]></title>
    <url>%2F2017%2F08%2F31%2Fwebpack%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[webpack的出现真正意义上使前端的工程化构建趋于完美，本篇将详细的讲讲webpack常用的配置选项。 webpack，browserify和RequireJswebpack算是近段时间来最火的一个模块打包工具了，要说及它的优点就不得不谈谈它的前辈browserify和RequireJs。 RequireJs当时有一个开发人员一直头疼的问题：js有方法或属性的依赖问题，所以引入js的顺序必须严格按照依赖的先后顺序来，这为我们多次加载js造成了困难，业务复杂的情况下使维护变得非常困难。为了解决这个问题，RequireJs出现了，它使模块的加载变得井井有条。 RequireJs是基于AMD规范的，也就是需要引入依赖的写法，如果写过ng1的童鞋应该对这种写法很熟悉，类似这样：12345678910//module.js 定义模块define(function () &#123; return function (a, b) &#123; console.log(a + b); &#125;&#125;);//引入require(['module'], function (module) &#123; module(1 + 2); // 3&#125;); 写惯了CommonJS写法的我，再回头看看这种写法，确实觉得累赘，但当时确实是一种很具有开创新的思想。RequireJs的require方法是一个异步方法，它可以保证在对应依赖都加载完成的情况下才执行回调函数，这使维护起来异常简便，你也不用担心加载顺序的问题，你只要关心依赖之间的关系就可以了。但这样还有个问题就是每个模块还是要引入对应的js，这样会发起多次http请求，对网页性能的影响很大，还好RequireJs提供了一个把各个模块整合到一个文件的工具，解决了多次加载文件的问题。 这个时候的RequireJs已经有webpack的雏形了。 browserify随着node的发展，前端的工程化被不断的推上日程，其中有一个最主要的问题是工程化道路上所必须面对的：目前的浏览器还是只能支持ES5的语法，而node环境下模块都是用CommonJS规范构建的，怎么才能把CommonJS的语法编译成浏览器认识的ES5语法呢？在这探索的路上，browserify就应此出现。 browserify做了两件事： 对用CommonJS规范构建的node模块进行转换和包装。 对node的大多数包进行了适配，使它们能更好的在浏览器里运行。 保证了node模块能在浏览器顺畅运行，踏出了前端工程化的重要一步。 webpackwebpack正是吸取了前辈的特点，将他们整合到一起，形成了一套比较完善的打包构建系统，它既有完善的打包流程，又能让node模块完美的兼容各类浏览器。 随着webpack的不断发展，生态圈越来越大，渐渐成了主流的打包构建工具，前端自动化，工程化已经不再只是设想了，webpack已经帮我们实现了！ webpack详解webpack常见配置讲解既然webpack那么好用，我们肯定要好好看看它是怎么配置的，写出适合自己项目的配置，大大提高开发效率！ 注意!本人用的是webpack@2.x版本，可能会与webpack@1.x版本的有些写法会不一样，下面会提到 webpack官网 已经把配置选项讲解的很详细了（现在文档也有中文版的翻译了，很贴心），太细节的就不深入了，我会把一些常见的配置项拿出来，说说他们的用途和一些可能会遇到的坑，先贴一张我个人项目中部分的webpack的配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const ExtractTextPlugin = require("extract-text-webpack-plugin");// 项目根路径const ROOT_PATH = path.resolve(__dirname);// 项目源码路径const SRC_PATH = ROOT_PATH + '/src';// 产出路径const DIST_PATH = ROOT_PATH + '/dist';// node_modulesconst NODE_MODULES_PATH = ROOT_PATH + '/node_modules';const __DEV__ = process.env.NODE_ENV !== 'production';module.exports = &#123; devtool: 'source-map', context: ROOT_PATH, entry: &#123; libs: [ 'react', 'react-dom', 'redux', 'react-redux', 'react-router', 'react-router-redux' ], app: [SRC_PATH + '/app.jsx'] &#125;, output: &#123; path: DIST_PATH, filename: __DEV__ ? 'js/[name].js' : 'js/[name].[chunkhash].js', chunkFilename: __DEV__ ? 'js/[name].js' : 'js/[name].[chunkhash].js', publicPath: '' &#125;, module: &#123; rules: [ &#123; test: /\.(jsx|js)$/, include: SRC_PATH, loader: 'babel-loader' &#125;] &#125;, resolve: &#123; modules: [SRC_PATH, "node_modules"], alias: &#123; 'react-router': NODE_MODULES_PATH + '/react-router/lib/index.js', 'react-redux': NODE_MODULES_PATH + '/react-redux/lib/index.js' &#125;, //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['.js', '.json', '.jsx'] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; collapseWhitespace: true &#125;, chunks: ['app', 'libs'], template: SRC_PATH + '/app.ejs' &#125;), new ExtractTextPlugin(&#123; filename: 'css/[name].[contenthash].css', disable: __DEV__, allChunks: true &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: ["libs","manifest"], minChunks: Infinity &#125;) ], watch: true, devServer: &#123; contentBase: path.join(__dirname, "dist"), compress: true, port: 9000 &#125;&#125; 我们不难发现，日常开发比较常用的就那么几个属性：entry、output、module、resolve、plugins、devtool，context，watch，devServer只不过根据项目的复杂度，具体的配置会有不同的变化，下面介绍一下具体每个属性的作用和对应的参数的作用。 entry根据词意，可以知道这是入口，简而言之就是你需要打包的入口js文件，路径和名称就在这里定义的，webpack打包的时候会找到这个入口文件，然后根据入口文件写入的依赖解析路径去引入对应的模块。写法也比较灵活，可以写成以下三种形式： 单页面应用入口，String类型 1entry: "./src/app.js" 多页面应用入口，Array类型 1entry: ["./src/app1.js","./src/app2.js"] 多页面应用入口，Object类型 1234entry: &#123; chunk1: "./src/app1.js", chunk2: "./src/app2.js"&#125; 如果想把不同的chunk区别开来，推荐用Object的形式，Object的key值对应了每个chunk的名称，使结构更清晰。 output该属性对应了打包的输出配置项，类似这样：123456output: &#123; path: './dist', filename:'js/[name].bundle.js',//或者'js/[id].bundle.js'、'js/[name].[hash].bundle.js'、'js/[chunkhash].bundle.js' chunkFilename:'js/[name].js', publicPath: '/'&#125; path 代表了打包后输出的目录路径，为绝对路径。 filename 代表了打包输出文件的名称，对应的是从入口进入的chunk打包后的文件名，其中[name]属性会被chunk的名字替换，[id]会被模块id（chunk id）所替换，[hash]会被每次构建产生的唯一的hash值替换，[chunkhash]会被根据chunk内容生成的hash值替换。 chunkFilename 是为了那些不是从标准入口进入的chunk命名用的，比较常见的就是通过CommonsChunkPlugin打包基础模块，比如react、redux这类的模块，而不是用户自己写的chunk模块，命名规则参考filename，是一样的。 publicPath这个配置项是为一些外部引入的资源如（图片，文件等）设置外部访问的公共URL，为什么要这么做呢？原因其实很简单，一句话概括就是开发环境和生产环境的不同，举个栗子：比如你在开发环境写代码的时候你有一张图片是这么引入的1234567891011121314// page/login/index.cssbackground-image:'../../img/login.png'//你的目录结构├── app.html├── app.js├── css│ └── index.css├── img│ └── logo.png└── page └── login ├── index.css └── login.js 之后不管你是启动本地服务器或者发布到正式环境，都会进行一次打包，不管打包进内存或到某个输出目录，你的目录结构可能就变成这样：123456//dist├── css│ └── app.css├── img│ └── logo.png└── index.html 很显然，目录的层级发生了变化，这时候你原先写的相对路径就变得不可靠了，会因找不到资源而报404，publicPath就是为了解决这个而提出的，它可以是相对路径也可以是绝对路径，以下摘一段官网的配置说明：123456publicPath: "https://cdn.example.com/assets/", // CDN（总是 HTTPS 协议）publicPath: "//cdn.example.com/assets/", // CDN (协议相同)publicPath: "/assets/", // 相对于服务(server-relative)publicPath: "assets/", // 相对于 HTML 页面publicPath: "../assets/", // 相对于 HTML 页面publicPath: "", // 相对于 HTML 页面（目录相同） 它当做相对路径写的时候可以相对于自己本身或者服务器的根目录的，所以我们之前如果设置了publicPath，比如这样：12publicPath: '/img/' //相对于服务器根目录publicPath: '../img/' //相对于自己 那么最后我们在app.css里面看到的路径就会是这样：123// app.cssbackground-image:'/img/login.png' //相对于服务器根目录background-image:'../img/login.png' //相对于自己 怎么样，这样就很清晰了吧。这里还得提一点需要注意的， output.publicPath只是默认构建的时候的全局配置，有些loader也有自己的publicPath，这就看具体情境了，如果loader也配置了，那默认就是以loader配置的为主。 有些童鞋很惧怕这种属性，觉得和Path很像，就默认是差不多用处了，不会再去深究。这样对知识的积累很不好，记住一个原则，配置或属性只是为了给我们提供方便，没必要去惧怕它，都是为了解决某些问题而提出的，当我们明白它的用途，我们才能更好的解读配置的意义。 devtooldevtool可以让打包后的文件支持source-map，以对打包压缩后的代码进行调试，贴一张官网的配置参数图：123456789devtool: "source-map", // enumdevtool: "inline-source-map", // 嵌入到源文件中devtool: "eval-source-map", // 将 SourceMap 嵌入到每个模块中devtool: "hidden-source-map", // SourceMap 不在源文件中引用devtool: "cheap-source-map", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)devtool: "cheap-module-source-map", // 有模块映射(module mappings)的 SourceMap 低级变体devtool: "eval", // 没有模块映射，而是命名模块。以牺牲细节达到最快。// 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试// 牺牲了构建速度的 `source-map' 是最详细的。 context该配置项设置webpack的主目录entry和 module.rules.loader选项相对于此目录解析，也就是以设置的目录为基准解析路径。 module这个选项为了处理项目中的不同类型的模块，配置也比较复杂，本文只拿常用的出来讲解，想看详细的配置说明请看官网，之前注释里说的webpack不同版本的问题，这里就有体现，对于webpack@1.x版本下，module的配置可能是下面这样：1234567module: &#123; loaders: [ &#123;test: /\.js$/, loader: 'babel'&#125;, &#123;test: /\.css$/, loader: 'style!css'&#125;, &#123;test: /\.(jpg|png|gif|svg)$/, loader: 'url?limit=8192&#125; ] &#125; 而webpack@2.x版本下，则写法统一改成这样：12345678module: &#123; rules: [ &#123; test: /\.(jsx|js)$/, include: SRC_PATH, loader: 'babel-loader' &#125;]&#125; 值得一提的是，不仅写法变了，webpack@2.x以后，-loader都不能被省略，不然会报语法错误。 rules是module的核心属性，它会提供一种规则数组，创建模块时，会去匹配并修改模块的创建方式。每个规则可以分为三部分条件(condition)，结果(result)和嵌套规则(nested rule)。 条件(condition)很好理解，举个栗子：12//app.jsimport './css/index.css' 条件(condition)包括了被引入文件./css/index.css和导入这个文件的模块app.js两个文件的绝对路径。你也可以通过制定test的规则去匹配和筛选条件(condition)所匹配的文件流。 结果(result)里面包含了一些loader，当条件(condition)满足时，会去匹配对应的被引入的文件流，对这些文件进行处理，生成对应的js模块。简单来说，对引入文件的预处理就在这里面，比如把ES6语法编译成ES5，把JSX编译成ES5，把引入的css，img转换成js模块等等。 嵌套规则(nested rule)可以使用属性rules和oneOf指定嵌套规则。这些规则用于在规则条件(rule condition)匹配时进行取值。 resolve这个选项能设置模块如何被解析，简单来说就是通过一定的规则去预定义webpack查找模块的方式，举个简单的栗子：比如你在app.js这样引入一个login模块12//app.jsimport login from './router/login'; 如果你设置了resolve参数，比如这样：1234//webpack.config.js alias: &#123; 'login':path.resolve(__dirname, 'src/router/login'), &#125; 你可以把之前的相对路径直接替换成：12//app.jsimport login from 'login'; 这样写是不是简洁不少？当webpack查找login模块时，会直接根据你设置的绝对路径去查找，当层级很深的时候，再按相对路径去找明显太蠢了，这样写不仅省时，代码的可读性也更高了，下面简单介绍一下它的其他几个参数（比较常用）。 extensions是用来自动解析模块扩展名的，这个懒人必备，哈哈，写法如下：12//webpack.config.jsextensions: [".js", ".json",".jsx"] 这样你再引入模块的时候就不用写扩展名了：123//app.jsimport userList from 'login/userList.jsx'; //设置之前import userList from 'login/userList'; //设置之后 设置之后，webpack再解析模块的时候会自动补全扩展名。 modules告诉webpack解析模块时应该搜索的目录。默认是搜索node_modules，搜索方式类似node通过相对路径一层层往上找。当我们想让webpack搜索指定目录，提高搜索效率的时候，也可以这么写12//webpack.config.jsmodules: [path.resolve(__dirname, "src"), "node_modules"] 这样webpack会在搜索node_modules之前先搜索你指定的目录，此路径应是绝对路径。 pluginsplugins为webpack的插件列表，这个看具体插件，不同插件的写法不同，但都是实例化了一个对象，比如这样：123456789101112131415161718plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; collapseWhitespace: true &#125;, chunks: ['app', 'libs'], template: SRC_PATH + '/app.ejs' &#125;), new ExtractTextPlugin(&#123; filename: 'css/[name].[contenthash].css', disable: __DEV__, allChunks: true &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: ["libs","manifest"], minChunks: Infinity &#125;) ] 善用插件可以帮我们简化开发流程，之后的博客会介绍一下比较常用webpack插件及其配置。 watchwatch模式意味着在初始构建之后，webpack将继续监听任何已解析文件的更改，这个配置项我们基本不用去设置，因为开了下面这个配置项是默认开启watch模式的。 devServerdevServer是webpack的本地服务器，它使我们的开发变的自动而高效，由于它的配置项很多，我们这里也只讲常用的几个。 contentBase告诉服务器从哪里提供内容，webpack的本地服务器本质上是一个通过node启动的本地资源服务器，这里要了解个概念，通过本地服务器打包是不会生成实体文件的，而是会写进内存里面，既然没实体文件，那我们能提供的静态资源也只能是我们本地的资源文件，这就是contentBase的作用，默认是项目根目录：1contentBase: '/' 当然你也可以自定义路径，比如我有一个目录结构是这样的：12345678.├── README.md├── node_modules├── package.json├── src│ ├── app.js│ └── index.html└── webpack.config.js 当你没设置contentBase时1234devServer: &#123; compress: true, port: 9000 &#125; 你启动本地服务器后，因为默认是项目根目录，也就是这样1http://localhost:9000/ 很显然，根目录下面没有静态资源可以加载的，我们的静态资源都在src里面，所以会出现下面的情况当我们进入src里面的时候发现资源加载成功了所以我们可以试着把contentBase加上12345devServer: &#123; contentBase: __dirname+'/src/', compress: true, port: 9000 &#125; 再启动本地服务器，会看到这么一句话1content is served from /Users/fengji/Desktop/demo/src/ 代表我们设置成功了，这时候你打开9000端口可以看到这样这样就请求到了我们本地资源，要是你嫌设置麻烦，推荐使用html-webpack-plugin它会帮你把资源路径正确定义到你html页面的文件夹下。 compress代表是否启用gzip 压缩，推荐都设置为true，加载压缩完后的资源能加快构建速度。 port为你要开启服务器的端口。 inline设置为true，webpack会把一段实时刷新页面的脚本内联进你打包后的bundle文件里，你可以在控制台实时看到构建的信息。设置为flase，则用iframe内嵌html的形式构建，消息会实时显示在页面上，两种方式都可以用，个人比较偏向启用，控制台看起来直观一点。 hot模式为不刷新页面的情况下进行模块的热替换，这个才是自动化构建的精髓啊，强烈推荐开启！来体验实时构建的快感吧。 多提一句，要开启hot模式，还需要一个插件的支持webpack.HotModuleReplacementPlugin，直接用就行了，也很方便。 配置讲解差不多就这么多了，有哪里说的不对的，欢迎在底下评论，大家一起交流进步，后面可能会讲一些插件的用法，或者构建一个完整项目的流程，怎么区分生产和开发环境等等。。 备注：本篇博客皆为博主原创，转发请标明出处。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈js的原型与继承]]></title>
    <url>%2F2017%2F08%2F26%2F%E8%B0%88%E8%B0%88js%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[javascript是一门弱类型的语言，所以并没有像java这种有类的概念，自然也没有子类继承父类这一说，但是所幸js有自己的一套继承机制，下面我就来谈谈关于js的继承我的一点微薄的理解。 构造函数js创建对象的方式有很多，比如对象字面量直接创建啊，类似这样：123//这种算是最简单的创建对象的方法，简单粗暴var obj = new Object();//或者var obj = &#123;&#125;; 或者工厂模式创建，类似这样：1234567891011//当你需要批量创建对象时可以用工厂模式统一创建function factory(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.dosth = function () &#123; console.log('做些事!'); &#125; return obj;&#125;var example1 = factory('redjue', 24) // &#123;name: "redjue", age: 24, dosth: ƒ&#125; 亦或者构造函数模式创建，类似这样：12345678910//构造函数解决了工厂模式反复创建函数方法的弊端，减少了对象的体积function constructor(name, age) &#123; this.name = name; this.age = age; constructor.prototype.dosth = function () &#123; console.log('做些事!'); &#125;&#125;var example2 = new constructor('redjue', 24);//&#123;name: "redjue", age: 24&#125;example2.dosth() //做些事! js的新手看到构造函数这可能会比较迷。。对象里没有dosth这个方法，它怎么还能调用到？是被什么‘吃’了吗，事实上它确实被‘吃’了，它被constructor的原型对象给接管了，具体形式如下：12345678//constructor.prototype&#123; dosth:function()&#123; console.log('做些事!'); &#125;, constructor:constructor(name, age)&#123;...&#125;, __proto__:Object &#125; 那么为什么example2能调用到constructor原型对象里的方法呢，构造函数的原型对象与他实例化的对象之间是通过什么连接起来的呢？这就要提到另一个概念，原型链的传递。 原型链的传递构造函数创建实例的过程构造函数通过new关键字来创建实例对象，具体过程如下： 创建一个空对象。 将构造函数的作用域赋值给这个空对象，也就是改变this指向。 根据构造函数中创建对象的代码，实例化这个空对象。 返回这个新对象。 我们一步步来看，创建一个空对象就是直接通过对象字面量直接创建一个对象：1var newObj = new Object(); 第二步中所做的，可以用以下代码表示： 123456789101112//让constructor构造函数在newObj的环境下执行，this自然指向newObjconstructor.call(newObj);//也可以形象的表示成这样newObj = &#123; constructor: function (name, age) &#123; this.name = name; this.age = age; this.constructor.prototype.dosth = function () &#123; console.log('做些事!'); &#125; &#125;&#125; 第三步，如下：12//当然constructor并没有在newObj里面，这段代码只是表示了和call函数做的一样的事newObj.constructor('redjue', 24); 第四步，返回构造函数的实例：1return newObj 至此，我们通过构造函数创建了一个实例对象，但是这个过程看起来似乎并没有关于原型链传递的操作对不对？其实嘛，js的底层都帮我们解决了，这里要介绍一个有关原型链传递的关键属性__proto__。 proto属性这个属性为什么能关乎原型链的传递呢？原因就在实例化对象的过程中，constructor把自己的原型对象当做一个属性值赋值给了newObj，而这个被赋值的属性就是__proto__，这是一个特殊的属性，专门用来保存指向对应原型的指针。所以当在调用实例对象自己本身没有的属性或方法时，通过这个属性的指向，我们可以去constructor的原型里面查找，这一过程称为原型链的传递。特别要注意的一点，这一过程只发生在实例对象与原型之间，而和constructor没什么关系。 ES5继承的实现为什么要说ES5继承呢，主要是ES6出了一个新特性class，通过更优雅的语法来实现继承，但本质上来说和ES5的继承方式是一样的，只不过是一个语法糖，后面再谈ES6继承的一些特性和实现原理。 常规的实现方式我们知道了原型链的传递是发生在实例对象和原型之间的，那么我们如果想要实现继承的话，就可以把它们连接起来，类似这样：123456789101112131415161718function parent()&#123; //父类 this.name='parent'; this.age=56; parent.prototype.dosth = function () &#123; console.log('做些事!');&#125; &#125;function child()&#123; //子类 this.name='child'; this.age=24;&#125;//连接原型链child.prototype=new parent();var child=new child();child.dosth() //'做些事!' 子类的实例对象可以通过搜索原型链往上找，最终找到父类原型里面的dosth方法。但是这样做有个问题，我们来看看子类的原型：123456//子类原型&#123; age: 56, name: "parent", __proto__: Object&#125; 发现问题了吗，子类的原型就是父类的实例对象，意味着这个实例对象里面的属性其实是作为原型里的属性而存在的，这违背了属性私有化的理念，我们只是想把方法进行复用，而属性并不需要共有。 借用构造实现组合继承既然我们遇到了这个问题，那么有没有什么办法能解决这个问题？有大神用了一种巧妙的办法规避了这个问题，这就是借用构造函数：12345678910111213141516171819202122function parent() &#123; //父类 this.name = 'parent'; this.age = 56; parent.prototype.dosth = function () &#123; console.log('做些事!'); &#125;&#125;function child() &#123; //子类 this.name = 'child'; this.age = 24; //将父类的属性在子类中私有化 parent.call(this);&#125;//连接原型链child.prototype = new parent();//将child原型的constructor指向child自身，默认状态指向的是parent，显然有问题child.prototype.constructor=child;var _child = new child();_child.dosth() //'做些事!' 这样我们保证了，child的每个实例对象都有parent定义的私有属性，而不是共享_child继承的parent的实例里面的共有属性，实现了属性私有，方法复用的比较完美的组合继承。 ES6继承的实现class，static，extend和super关键字ES6引入了一个新的概念class，也就是类，形式类似这样：12345678910class parent &#123; constructor() &#123; this.name = 'redjue'; this.age = 24 &#125; dosth() &#123; console.log('做些事!') &#125;&#125;var _parent = new parent;//&#123;name: "redjue", age: 24&#125; 粗粗一看，哇，好高大上的感觉，但是仔细看看类里面的内容，卧槽，这不就是原型对象里面的东西吗。。如果我们把_parent这个实例的原型打印出来，如下所示：12345&#123; constructor: class parent, dosth: ƒ dosth(), __proto__:Object&#125; 是不是一目了然了，class里面定义的就是原型对象里面的属性而已，通过class关键字，我们可以在class里面一起定义原型属性和构造函数的自定义属性，这种方式相比较ES5的在构造函数里定义显的更加优雅和直观，通过类来new一个对象也就顺理成章，不会像ES5用构造函数来new一个对象那么生硬。 接下来说说static关键字，这个很有意思，他可以隔离实例与原型对象的联系，换句话说，你用static定义的方法，并不能被实例所访问到，所以是静态的，而不是共有的，类似下面这样：123456789101112131415class parent &#123; constructor() &#123; this.name = 'redjue'; this.age = 24 &#125; static ifVisit() &#123; console.log('访问到了！') &#125; dosth() &#123; console.log('做些事!') &#125;&#125;var _parent = new parent();_parent.ifVisit();//_parent.ifVisit is not a functionparent.ifVisit();//访问到了！ 这给我们在某些特定情况下不想让实例访问我们原型里定义的方法提供了方便，也更严谨了。 ES6提出了一种全新的继承方式，形式和java的继承看上去很像，通过extend关键字来实现：1234567891011121314151617class parent &#123; constructor() &#123; this.name = 'redjue'; this.age = 24 &#125; dosth() &#123; console.log('做些事!') &#125;&#125;class child extends parent &#123; constructor() &#123; super(); this.career = 'programmer' &#125;&#125;var _child = new child();//&#123;name: "redjue", age: 24, career: "programmer"&#125;_child.dosth();//做些事! 完美！既把父类的属性私有化了，又继承到了父类原型里的dosth方法，让我们把_child的原型输出来看看：1234&#123; constructor: class child, __proto__: Object&#125; 我们发现原型的constructor指向的是class child，那父类的属性是怎么跑到子类里的呢？，秘密就在super关键字。 super关键字和我们之前探讨过的ES5继承里面的借用构造其实是一个意思，super是ES6向我们提供的语法糖而已，等价于ES5的parent.call(this),区别在于ES6语法规定不用super关键字就没有this指向，所以不能直接替换用，只是底层原理是类似的：12345678&#123; class child extends parent &#123; constructor() &#123; super();//类似于parent.call(this) this.career = 'programmer' &#125;&#125;&#125; ES6继承实现的原理ES6实现继承其实也就走了两条路，属性的私有化和方法的共有化，大致过程如下：12class child.__proto__=class parent;//属性私有化class child.prototype.__proto__=class parent.prototype;//方法共有化 ES5的组合继承根本上讲也就是为了实现以上两种情况，只不过ES6的实现更加优雅，还有一点值得指出来的是，ES5构造函数的__proto__永远指向的是Function对象的原型，不会因为实例的继承而改变指向，而在ES6中不一样，当子类继承父类之后，子类的__proto__会指向父类，这样表示显得更加规范，也清楚明了的表示了子类继承了父类的属性。 备注：本篇博客皆为博主原创，转发请标明出处。]]></content>
      <tags>
        <tag>原型与继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈浏览器加载优化]]></title>
    <url>%2F2017%2F07%2F19%2F%E6%B5%85%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[呼~总算搞定了博客，终于可以写一点自己的东西了，第一篇博客就来聊聊关于浏览器加载速度的话题，这个直接关乎用户在浏览我们网站时候的体验，也是作为我们前端工程师所必须了解的。 浏览器加载网页的过程既然要探讨加载问题，我们首先得先知道浏览器是怎么加载网页的，知道了加载过程，就能针对其中的一些点进行不同程度的优化，浏览器加载网页的过程大致分为以下几步： 浏览器接受到服务器的html响应，开始以8k / chunk的速度开始下载html页面 浏览器开始解析页面代码，并开始构建DOM树 遇到css标签或者js标签就重新开启线程去下载对应的文件，然后继续构建DOM树 当css文件下载完后，开始解析css为CSS规则树，然后浏览器根据CSS规则树和DOM树生成render tree，也就是开始渲染页面了 当js文件下载完后，开始解析js文件，若js文件里有修改dom的DOM API 或者修改css样式的CSSOM API，每次执行都会使render tree重新渲染，相比而言，修改dom的代价更高，它会使render tree重新布局构建（reflow）然后进行重新渲染（repaint），而修改样式只会触发重新渲染。 渲染完成，显示页面 简单优化的一些建议压缩css和javascript文件既然是从服务器上下载下来的，首先想到的自然就是减少下载下来的文件体积。压缩就是一个很好的办法，市面上有很多工具可以帮助我们完成压缩的工作，个人比较推荐用Uglify，这是一个用来完成压缩操作的包，可以配合一些任务流工具如grunt，gulp来快速压缩我们生产环境所需要的js和css文件，因为这是npm的包，所以你必须先装有node和npm。安装去官网找一下就可以了。 安装Uglify的指令为： 1npm install uglify-js -g 使用也很简单，博主在这就不展开了，具体文档点这里。 启用GZIP压缩压缩完css和javascript文件，我们是不是也能把html页面也压缩一下呢，毕竟页面是最先下载的，要是能压缩体积，必定能提升网站的访问速度。我们可以在服务器上通过Gzip压缩做到这一点，这能有效减少HTTP响应的时间，提高访问速度。 使用 CSS Sprites俗称css精灵或雪碧图，把多个小图片整合到一张大图片中，需要取某张图片的话，通过background-position来定位需要的图片，这样资源只需要请求一次，不需要多次请求，常见的应用就是各种图标的整合，有效提高了打开网站的速度。 CSS文件放在页面顶部，而JS文件放在底部根据我们之前了解的网站加载过程，可以知道css是用来渲染整颗DOM树的，那么如果放在页面最后面的话，等DOM树构建完成，再开始生成render tree，然后浏览器不得不重新渲染整颗树，这样显然效率不高，网速慢的话容易出现短暂的视觉空白，影响用户体验。 而对于js文件来说，它会阻塞DOM树的构建，若放在head标签中，显然不合理，无法让用户第一时间看到页面，所以放在body标签的最后是比较合理的。 利用浏览器的缓存浏览器自带缓存功能，能避免重复文件的多次下载，但是这个有时候也是个缺点，若有一些新的文件的版本更新，浏览器里可能还留着老版本文件的缓存导致不能更新到最新版本，这点对于一些更新频繁的网站是致命的，解决办法是给文件后面加v=版本号，使有文件更新的时候去服务器端重新下载最新的文件。 使用内容分发网络(CDN)当一个网站的流量很大的时候，会对服务器造成很大的压力，处理的东西多了自然用户打开页面的时候就慢了，CDN主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，不同地区的用户的用户可以就近访问对应的节点，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。 减少重定向重定向增加了额外的HTTP请求，也增加了页面加载时间。 备注：本篇博客皆为博主原创，转发请标明出处。]]></content>
      <tags>
        <tag>浏览器加载优化</tag>
      </tags>
  </entry>
</search>
