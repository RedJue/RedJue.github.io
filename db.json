{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/.DS_Store","hash":"f9e17e1becf7474a7c09f0e7ee63b138b5e54b6e","modified":1578364314506},{"_id":"source/_posts/.DS_Store","hash":"c8e3546ba19b8744ee4470150a5504b22a86610d","modified":1578364314506},{"_id":"source/_posts/webpack常用插件整理.md","hash":"f8e46ac05aacdbd7d767d4a6b97da2a8f5647d8a","modified":1578364314506},{"_id":"source/_posts/webpack的配置解析.md","hash":"0dc2c8153827f9a008d1dd278836debf8f7abb33","modified":1578364314506},{"_id":"source/_posts/工作中遇到的bug整理.md","hash":"72b8124371719bb88c554df799add331350fc4fe","modified":1578364314508},{"_id":"source/_posts/浅谈浏览器加载优化.md","hash":"06a1f23042cfe416fc07b9883faf421b28bd2c3d","modified":1578364314508},{"_id":"source/_posts/谈谈js的原型与继承.md","hash":"1d419bc905004a8fb5881ea02901fabd667e7ca5","modified":1578364314509},{"_id":"source/categories/index.md","hash":"334d97df0ae7dfa4ea514a76477310773182339c","modified":1578364314509},{"_id":"source/tags/index.md","hash":"06f0fe45f3e8f29af066dc57565e755bbd9dcd24","modified":1578364314509},{"_id":"source/_posts/webpack常用插件整理/.DS_Store","hash":"16583c4036a87ee940f76f52760a24ce4e711d46","modified":1578364314506},{"_id":"source/_posts/webpack常用插件整理/timg.jpg","hash":"4b5f971e482b41589ba7465715c499dfb206187c","modified":1578364314506},{"_id":"source/_posts/webpack的配置解析/.DS_Store","hash":"a40384487e4a4d7178eafb7f3b8fc5dbd1c6c3f9","modified":1578364314506},{"_id":"source/_posts/webpack的配置解析/error.png","hash":"8f37dd68b5b2f8fedc547721ffcc2444af66abab","modified":1578364314507},{"_id":"source/_posts/webpack的配置解析/webpack.jpg","hash":"cbe5f5558531046cc6a340df6993f898b8a92e5c","modified":1578364314507},{"_id":"source/_posts/工作中遇到的bug整理/.DS_Store","hash":"e4ec50ee2b4afb06d4ec782e9227c49584e765b2","modified":1578364314508},{"_id":"source/_posts/工作中遇到的bug整理/bug.jpg","hash":"87e60e2bb8512e38d5134caa61597af0c7716911","modified":1578364314508},{"_id":"source/_posts/谈谈js的原型与继承/.DS_Store","hash":"54448107eead992507dbf5a3fbc9f874e32a1ff2","modified":1578364314509},{"_id":"source/_posts/谈谈js的原型与继承/pic.jpg","hash":"37a68299c62390fa8ab3b231b1770b96f22bbbfd","modified":1578364314509},{"_id":"source/_posts/webpack的配置解析/success.png","hash":"e51c82abd6938809f6b3151869f7c3668e407794","modified":1578364314507},{"_id":"source/_posts/webpack的配置解析/work.png","hash":"2f0893b68640cd991cebb09c7dab5b51f870373f","modified":1578364314508},{"_id":"source/_posts/浅谈浏览器加载优化/render_dom.png","hash":"a6590d95796ba9f03d3ca8b6b1b5fcc212dff7b2","modified":1578364314509},{"_id":"public/search.xml","hash":"f0a4291e6d9b56433a5042745ea2dcb4889d811b","modified":1578367155073},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/2018/04/02/工作中遇到的bug整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/2017/09/19/webpack常用插件整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/2017/08/31/webpack的配置解析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/2017/08/26/谈谈js的原型与继承/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/2017/07/19/浅谈浏览器加载优化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155078},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/archives/2017/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/archives/2017/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/archives/2017/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/archives/2018/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/tags/webpack-plugin/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/tags/webpack/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155079},{"_id":"public/tags/bugs/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155080},{"_id":"public/tags/浏览器加载优化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155080},{"_id":"public/tags/原型与继承/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578367155080},{"_id":"public/2017/09/19/webpack常用插件整理/timg.jpg","hash":"4b5f971e482b41589ba7465715c499dfb206187c","modified":1578367155090},{"_id":"public/2018/04/02/工作中遇到的bug整理/bug.jpg","hash":"87e60e2bb8512e38d5134caa61597af0c7716911","modified":1578367155091},{"_id":"public/2017/08/31/webpack的配置解析/error.png","hash":"8f37dd68b5b2f8fedc547721ffcc2444af66abab","modified":1578367155091},{"_id":"public/2017/08/31/webpack的配置解析/webpack.jpg","hash":"cbe5f5558531046cc6a340df6993f898b8a92e5c","modified":1578367155091},{"_id":"public/2017/07/19/浅谈浏览器加载优化/render_dom.png","hash":"a6590d95796ba9f03d3ca8b6b1b5fcc212dff7b2","modified":1578367155106},{"_id":"public/2017/08/26/谈谈js的原型与继承/pic.jpg","hash":"37a68299c62390fa8ab3b231b1770b96f22bbbfd","modified":1578367155106},{"_id":"public/2017/08/31/webpack的配置解析/success.png","hash":"e51c82abd6938809f6b3151869f7c3668e407794","modified":1578367155106},{"_id":"public/2017/08/31/webpack的配置解析/work.png","hash":"2f0893b68640cd991cebb09c7dab5b51f870373f","modified":1578367155106}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2017-07-19T14:23:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-07-19 22:23:20\ntype: \"categories\"\n---\n","updated":"2020-01-07T02:31:54.509Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck53b1uph000d0vk5zaum1yk6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-07-19T13:23:41.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-07-19 21:23:41\ntype: \"tags\"\n---\n","updated":"2020-01-07T02:31:54.509Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck53b1upi000e0vk5txh47e4m","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"webpack常用插件整理","date":"2017-09-19T11:54:15.000Z","_content":"![webpack常用插件整理](webpack常用插件整理/timg.jpg)\n\nwebpack有很多很好用的插件，它们帮助我们日常的开发效率提高了不少，本篇博客将着重介绍一些通用的插件，适合不同框架的项目使用。\n\n<!-- more -->\n\n## <mblue>html-webpack-plugin</mblue>\n\n一个项目，不管是多页面应用还是单页面应用，都需要有<mred>html</mred>页面来承载内容，本来是一件比较容易的事，但是在<mred>webpack</mred>这个环境下，有些地方会让人觉得不是很舒服。\n### 静态资源路径问题\n举个最简单的栗子，上次讲解<mred>webpack</mred>配置的时候也提过，就是开启本地服务器需要配置静态资源目录路径。\n```javascript\ncontentBase: '/' //默认解析静态资源的路径\ncontentBase: '/src/' //手动指向静态资源目录的路径\n```\n这是其中一个麻烦的点，不同项目还得配不同的<mred>contentBase<mred>参数。\n### 不能跟随js一起打包\n<mred>webpack</mred>并没有那么智能会去解<mred>index.html</mred>的路径，它的设计初衷只是为了打包js而已，也就是如果你在资源目录里创建了一个<mred>html</mred>文件，<mred>webpack</mred>并不认识，自然也就不会自动打包到对应的打包目录，单页面还好，多页面的话简直是噩梦，还要自己手动<mred>copy</mred>页面，每次打包都会清空一次打包目录，意味着要一直重复这种操作，太累了。\n### 页面引用资源的相对路径\n最绝望的是如果你原来页面写的是相对路径来访问一些静态资源，转到打包目录，结构层次不一样，路径全得改。。。不敢想下去了，大工程啊。\n### 无法便捷的利用缓存机制\n想有效利用缓存，最方便的就是给引入的文件后缀加<mred>hash</mred>值或者时间戳，保证该文件的唯一性，这样当浏览器去解析该文件的时候，如果之前下载过，会直接读取缓存，减少一次请求资源的操作。但是每次你改了静态资源的内容，由于你需要更新内容，不得不改变对应的<mred>hash</mred>值，然后你需要自己手动改。。太麻烦了，这样一点都不自动化。\n### html-webpack-plugin参数简介\n以上的问题，我们可以通过<mred>html-webpack-plugin</mred>来进行解决，配置该插件也非常方便，如下：\n\n```javascript\nnew HtmlWebpackPlugin({\n            //html文件的标题\n            title: 'My App',\n            //简易压缩html文件的体积，去空格\n            minify: {        \n                collapseWhitespace: true\n            },\n            //会将hash值添加到每个引入的js和css文件上\n            hash:true, \n            //允许生成的html页面上引入不同的chunkjs，而不是默认的入口js   \n            chunks: ['app', 'libs'], \n            //Webpack需要的模板的路径，用过模板文件的童鞋应该知道是干嘛的\n            template: SRC_PATH + '/app.ejs', \n            //要写入HTML的文件。默认为index.html。您也可以在这里指定一个子目录（例如：assets / admin.html）。\n            filename: 'index.html'         }),\n```\n其他一些具体的参数参考[<mlink>这里</mlink>](https://github.com/jantimon/html-webpack-plugin#configuration)，对应的模板文件参考如下写法：\n\n```javascript\n//app.ejs\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"/>\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n  </body>\n</html>\n```\n当然你直接用html文件也是一样的，剩下的<mred>html-webpack-plugin</mred>会帮你搞定的，享受自动化的构建体验吧！\n\n## <mblue>extract-text-webpack-plugin</mblue>\n\n当我们开发的时候，<mred>css-loader</mred>和<mred>style-loader</mred>可以方便的把样式打包进js里面，并以<mred>style</mred>标签形式内嵌在页面上,这为我们提供了方便，因为是打包进去的，所以也支持<mred>webpack</mred>的热更新，但在生产环境下就比较尴尬了，具体有以下几个问题：\n\n### 内嵌的结构不清晰，增大了页面的体积\n这个问题反映在比较大的项目里，<mred>css</mred>通常都会比较多，全部挤在一起，也不易维护和调试。由于是内嵌的代码也无法使用<mred>sources map</mred>，代码的优雅性也大大降低。\n\n### 无法有效利用缓存机制和CDN\n给文件后缀加hash或时间戳是利用缓存的常用形式，但这局限于css实体文件，<mred>CDN</mred>引流资源也是一样，内嵌的形式限制了很多功能的实现。\n\n### extract-text-webpack-plugin参数简介\n为了享受实体<mred>css</mred>文件的好处，我们选择了这个插件来处理<mred>css-loader</mred>处理过的<mred>css</mred>模块，下面贴出常用的一些配置属性：\n\n```javascript\nnew ExtractTextPlugin({\n            //默认自动生成，id为此插件实例的唯一标识符\n            id:chunkId,\n            //输出的css文件名，可以包括[name]，[id]和[contenthash]\n            filename: 'css/[name].[contenthash].css',\n            //禁用插件\n            disable: __DEV__,\n            //从所有附加chunk中提取css文件（默认情况下，它仅从初始块中提取）， 当使用CommonsChunkPlugin并且在commons chunk中有提取的块时，allChunks必须设置为true\n            allChunks: true\n        })\n```\n这样配置只能提取纯<mred>css</mred>样式，如果我们项目中有用一些<mred>css预编译器</mred>，比如<mred>sass</mred>，<mred>less</mred>，<mred>styl</mred>等等，光这样还不够，我们还需要配置另一个方法：\n```javascript\nExtractTextPlugin.extract({\n    //当CSS未被提取时应该使用的loader\n    fallback: \"style-loader\",\n    //将资源通过配置的loader来转换为css（必填，支持预处理器就靠这个参数）\n    use: ['css-loader', 'sass-loader'],\n    //覆盖默认的publicPath设置\n    publicPath:'/'\n});\n```\n如果配置顺利的话，最后打包上线在页面上显示的应该就是这个样子：\n```javascript\n<link href=\"css/app.ff056f366d9a3c7632b010597cbcd7ba.css\" rel=\"stylesheet\">\n```\n这符合我们的预期，通过配置，我们也可以区别生产和开发环境，这个以后会讨论。","source":"_posts/webpack常用插件整理.md","raw":"---\ntitle: webpack常用插件整理\ndate: 2017-09-19 19:54:15\ntags: webpack plugin\n---\n![webpack常用插件整理](webpack常用插件整理/timg.jpg)\n\nwebpack有很多很好用的插件，它们帮助我们日常的开发效率提高了不少，本篇博客将着重介绍一些通用的插件，适合不同框架的项目使用。\n\n<!-- more -->\n\n## <mblue>html-webpack-plugin</mblue>\n\n一个项目，不管是多页面应用还是单页面应用，都需要有<mred>html</mred>页面来承载内容，本来是一件比较容易的事，但是在<mred>webpack</mred>这个环境下，有些地方会让人觉得不是很舒服。\n### 静态资源路径问题\n举个最简单的栗子，上次讲解<mred>webpack</mred>配置的时候也提过，就是开启本地服务器需要配置静态资源目录路径。\n```javascript\ncontentBase: '/' //默认解析静态资源的路径\ncontentBase: '/src/' //手动指向静态资源目录的路径\n```\n这是其中一个麻烦的点，不同项目还得配不同的<mred>contentBase<mred>参数。\n### 不能跟随js一起打包\n<mred>webpack</mred>并没有那么智能会去解<mred>index.html</mred>的路径，它的设计初衷只是为了打包js而已，也就是如果你在资源目录里创建了一个<mred>html</mred>文件，<mred>webpack</mred>并不认识，自然也就不会自动打包到对应的打包目录，单页面还好，多页面的话简直是噩梦，还要自己手动<mred>copy</mred>页面，每次打包都会清空一次打包目录，意味着要一直重复这种操作，太累了。\n### 页面引用资源的相对路径\n最绝望的是如果你原来页面写的是相对路径来访问一些静态资源，转到打包目录，结构层次不一样，路径全得改。。。不敢想下去了，大工程啊。\n### 无法便捷的利用缓存机制\n想有效利用缓存，最方便的就是给引入的文件后缀加<mred>hash</mred>值或者时间戳，保证该文件的唯一性，这样当浏览器去解析该文件的时候，如果之前下载过，会直接读取缓存，减少一次请求资源的操作。但是每次你改了静态资源的内容，由于你需要更新内容，不得不改变对应的<mred>hash</mred>值，然后你需要自己手动改。。太麻烦了，这样一点都不自动化。\n### html-webpack-plugin参数简介\n以上的问题，我们可以通过<mred>html-webpack-plugin</mred>来进行解决，配置该插件也非常方便，如下：\n\n```javascript\nnew HtmlWebpackPlugin({\n            //html文件的标题\n            title: 'My App',\n            //简易压缩html文件的体积，去空格\n            minify: {        \n                collapseWhitespace: true\n            },\n            //会将hash值添加到每个引入的js和css文件上\n            hash:true, \n            //允许生成的html页面上引入不同的chunkjs，而不是默认的入口js   \n            chunks: ['app', 'libs'], \n            //Webpack需要的模板的路径，用过模板文件的童鞋应该知道是干嘛的\n            template: SRC_PATH + '/app.ejs', \n            //要写入HTML的文件。默认为index.html。您也可以在这里指定一个子目录（例如：assets / admin.html）。\n            filename: 'index.html'         }),\n```\n其他一些具体的参数参考[<mlink>这里</mlink>](https://github.com/jantimon/html-webpack-plugin#configuration)，对应的模板文件参考如下写法：\n\n```javascript\n//app.ejs\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"/>\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n  </body>\n</html>\n```\n当然你直接用html文件也是一样的，剩下的<mred>html-webpack-plugin</mred>会帮你搞定的，享受自动化的构建体验吧！\n\n## <mblue>extract-text-webpack-plugin</mblue>\n\n当我们开发的时候，<mred>css-loader</mred>和<mred>style-loader</mred>可以方便的把样式打包进js里面，并以<mred>style</mred>标签形式内嵌在页面上,这为我们提供了方便，因为是打包进去的，所以也支持<mred>webpack</mred>的热更新，但在生产环境下就比较尴尬了，具体有以下几个问题：\n\n### 内嵌的结构不清晰，增大了页面的体积\n这个问题反映在比较大的项目里，<mred>css</mred>通常都会比较多，全部挤在一起，也不易维护和调试。由于是内嵌的代码也无法使用<mred>sources map</mred>，代码的优雅性也大大降低。\n\n### 无法有效利用缓存机制和CDN\n给文件后缀加hash或时间戳是利用缓存的常用形式，但这局限于css实体文件，<mred>CDN</mred>引流资源也是一样，内嵌的形式限制了很多功能的实现。\n\n### extract-text-webpack-plugin参数简介\n为了享受实体<mred>css</mred>文件的好处，我们选择了这个插件来处理<mred>css-loader</mred>处理过的<mred>css</mred>模块，下面贴出常用的一些配置属性：\n\n```javascript\nnew ExtractTextPlugin({\n            //默认自动生成，id为此插件实例的唯一标识符\n            id:chunkId,\n            //输出的css文件名，可以包括[name]，[id]和[contenthash]\n            filename: 'css/[name].[contenthash].css',\n            //禁用插件\n            disable: __DEV__,\n            //从所有附加chunk中提取css文件（默认情况下，它仅从初始块中提取）， 当使用CommonsChunkPlugin并且在commons chunk中有提取的块时，allChunks必须设置为true\n            allChunks: true\n        })\n```\n这样配置只能提取纯<mred>css</mred>样式，如果我们项目中有用一些<mred>css预编译器</mred>，比如<mred>sass</mred>，<mred>less</mred>，<mred>styl</mred>等等，光这样还不够，我们还需要配置另一个方法：\n```javascript\nExtractTextPlugin.extract({\n    //当CSS未被提取时应该使用的loader\n    fallback: \"style-loader\",\n    //将资源通过配置的loader来转换为css（必填，支持预处理器就靠这个参数）\n    use: ['css-loader', 'sass-loader'],\n    //覆盖默认的publicPath设置\n    publicPath:'/'\n});\n```\n如果配置顺利的话，最后打包上线在页面上显示的应该就是这个样子：\n```javascript\n<link href=\"css/app.ff056f366d9a3c7632b010597cbcd7ba.css\" rel=\"stylesheet\">\n```\n这符合我们的预期，通过配置，我们也可以区别生产和开发环境，这个以后会讨论。","slug":"webpack常用插件整理","published":1,"updated":"2020-01-07T02:31:54.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck53b1up000000vk5qyfsedlq","content":"<p><img src=\"/2017/09/19/webpack常用插件整理/timg.jpg\" alt=\"webpack常用插件整理\"></p>\n<p>webpack有很多很好用的插件，它们帮助我们日常的开发效率提高了不少，本篇博客将着重介绍一些通用的插件，适合不同框架的项目使用。</p>\n<a id=\"more\"></a>\n<h2 id=\"html-webpack-plugin\"><a href=\"#html-webpack-plugin\" class=\"headerlink\" title=\"html-webpack-plugin\"></a><mblue>html-webpack-plugin</mblue></h2><p>一个项目，不管是多页面应用还是单页面应用，都需要有<mred>html</mred>页面来承载内容，本来是一件比较容易的事，但是在<mred>webpack</mred>这个环境下，有些地方会让人觉得不是很舒服。</p>\n<h3 id=\"静态资源路径问题\"><a href=\"#静态资源路径问题\" class=\"headerlink\" title=\"静态资源路径问题\"></a>静态资源路径问题</h3><p>举个最简单的栗子，上次讲解<mred>webpack</mred>配置的时候也提过，就是开启本地服务器需要配置静态资源目录路径。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contentBase: <span class=\"string\">'/'</span> <span class=\"comment\">//默认解析静态资源的路径</span></span><br><span class=\"line\">contentBase: <span class=\"string\">'/src/'</span> <span class=\"comment\">//手动指向静态资源目录的路径</span></span><br></pre></td></tr></table></figure></p>\n<p>这是其中一个麻烦的点，不同项目还得配不同的<mred>contentBase<mred>参数。</mred></mred></p>\n<h3 id=\"不能跟随js一起打包\"><a href=\"#不能跟随js一起打包\" class=\"headerlink\" title=\"不能跟随js一起打包\"></a>不能跟随js一起打包</h3><p><mred>webpack</mred>并没有那么智能会去解<mred>index.html</mred>的路径，它的设计初衷只是为了打包js而已，也就是如果你在资源目录里创建了一个<mred>html</mred>文件，<mred>webpack</mred>并不认识，自然也就不会自动打包到对应的打包目录，单页面还好，多页面的话简直是噩梦，还要自己手动<mred>copy</mred>页面，每次打包都会清空一次打包目录，意味着要一直重复这种操作，太累了。</p>\n<h3 id=\"页面引用资源的相对路径\"><a href=\"#页面引用资源的相对路径\" class=\"headerlink\" title=\"页面引用资源的相对路径\"></a>页面引用资源的相对路径</h3><p>最绝望的是如果你原来页面写的是相对路径来访问一些静态资源，转到打包目录，结构层次不一样，路径全得改。。。不敢想下去了，大工程啊。</p>\n<h3 id=\"无法便捷的利用缓存机制\"><a href=\"#无法便捷的利用缓存机制\" class=\"headerlink\" title=\"无法便捷的利用缓存机制\"></a>无法便捷的利用缓存机制</h3><p>想有效利用缓存，最方便的就是给引入的文件后缀加<mred>hash</mred>值或者时间戳，保证该文件的唯一性，这样当浏览器去解析该文件的时候，如果之前下载过，会直接读取缓存，减少一次请求资源的操作。但是每次你改了静态资源的内容，由于你需要更新内容，不得不改变对应的<mred>hash</mred>值，然后你需要自己手动改。。太麻烦了，这样一点都不自动化。</p>\n<h3 id=\"html-webpack-plugin参数简介\"><a href=\"#html-webpack-plugin参数简介\" class=\"headerlink\" title=\"html-webpack-plugin参数简介\"></a>html-webpack-plugin参数简介</h3><p>以上的问题，我们可以通过<mred>html-webpack-plugin</mred>来进行解决，配置该插件也非常方便，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">            <span class=\"comment\">//html文件的标题</span></span><br><span class=\"line\">            title: <span class=\"string\">'My App'</span>,</span><br><span class=\"line\">            <span class=\"comment\">//简易压缩html文件的体积，去空格</span></span><br><span class=\"line\">            minify: &#123;        </span><br><span class=\"line\">                collapseWhitespace: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//会将hash值添加到每个引入的js和css文件上</span></span><br><span class=\"line\">            hash:<span class=\"literal\">true</span>, </span><br><span class=\"line\">            <span class=\"comment\">//允许生成的html页面上引入不同的chunkjs，而不是默认的入口js   </span></span><br><span class=\"line\">            chunks: [<span class=\"string\">'app'</span>, <span class=\"string\">'libs'</span>], </span><br><span class=\"line\">            <span class=\"comment\">//Webpack需要的模板的路径，用过模板文件的童鞋应该知道是干嘛的</span></span><br><span class=\"line\">            template: SRC_PATH + <span class=\"string\">'/app.ejs'</span>, </span><br><span class=\"line\">            <span class=\"comment\">//要写入HTML的文件。默认为index.html。您也可以在这里指定一个子目录（例如：assets / admin.html）。</span></span><br><span class=\"line\">            filename: <span class=\"string\">'index.html'</span>         &#125;),</span><br></pre></td></tr></table></figure>\n<p>其他一些具体的参数参考<a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\" target=\"_blank\" rel=\"noopener\"><mlink>这里</mlink></a>，对应的模板文件参考如下写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.ejs</span></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=<span class=\"string\">\"Content-type\"</span> content=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当然你直接用html文件也是一样的，剩下的<mred>html-webpack-plugin</mred>会帮你搞定的，享受自动化的构建体验吧！</p>\n<h2 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a><mblue>extract-text-webpack-plugin</mblue></h2><p>当我们开发的时候，<mred>css-loader</mred>和<mred>style-loader</mred>可以方便的把样式打包进js里面，并以<mred>style</mred>标签形式内嵌在页面上,这为我们提供了方便，因为是打包进去的，所以也支持<mred>webpack</mred>的热更新，但在生产环境下就比较尴尬了，具体有以下几个问题：</p>\n<h3 id=\"内嵌的结构不清晰，增大了页面的体积\"><a href=\"#内嵌的结构不清晰，增大了页面的体积\" class=\"headerlink\" title=\"内嵌的结构不清晰，增大了页面的体积\"></a>内嵌的结构不清晰，增大了页面的体积</h3><p>这个问题反映在比较大的项目里，<mred>css</mred>通常都会比较多，全部挤在一起，也不易维护和调试。由于是内嵌的代码也无法使用<mred>sources map</mred>，代码的优雅性也大大降低。</p>\n<h3 id=\"无法有效利用缓存机制和CDN\"><a href=\"#无法有效利用缓存机制和CDN\" class=\"headerlink\" title=\"无法有效利用缓存机制和CDN\"></a>无法有效利用缓存机制和CDN</h3><p>给文件后缀加hash或时间戳是利用缓存的常用形式，但这局限于css实体文件，<mred>CDN</mred>引流资源也是一样，内嵌的形式限制了很多功能的实现。</p>\n<h3 id=\"extract-text-webpack-plugin参数简介\"><a href=\"#extract-text-webpack-plugin参数简介\" class=\"headerlink\" title=\"extract-text-webpack-plugin参数简介\"></a>extract-text-webpack-plugin参数简介</h3><p>为了享受实体<mred>css</mred>文件的好处，我们选择了这个插件来处理<mred>css-loader</mred>处理过的<mred>css</mred>模块，下面贴出常用的一些配置属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">            <span class=\"comment\">//默认自动生成，id为此插件实例的唯一标识符</span></span><br><span class=\"line\">            id:chunkId,</span><br><span class=\"line\">            <span class=\"comment\">//输出的css文件名，可以包括[name]，[id]和[contenthash]</span></span><br><span class=\"line\">            filename: <span class=\"string\">'css/[name].[contenthash].css'</span>,</span><br><span class=\"line\">            <span class=\"comment\">//禁用插件</span></span><br><span class=\"line\">            disable: __DEV__,</span><br><span class=\"line\">            <span class=\"comment\">//从所有附加chunk中提取css文件（默认情况下，它仅从初始块中提取）， 当使用CommonsChunkPlugin并且在commons chunk中有提取的块时，allChunks必须设置为true</span></span><br><span class=\"line\">            allChunks: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n<p>这样配置只能提取纯<mred>css</mred>样式，如果我们项目中有用一些<mred>css预编译器</mred>，比如<mred>sass</mred>，<mred>less</mred>，<mred>styl</mred>等等，光这样还不够，我们还需要配置另一个方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当CSS未被提取时应该使用的loader</span></span><br><span class=\"line\">    fallback: <span class=\"string\">\"style-loader\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//将资源通过配置的loader来转换为css（必填，支持预处理器就靠这个参数）</span></span><br><span class=\"line\">    use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'sass-loader'</span>],</span><br><span class=\"line\">    <span class=\"comment\">//覆盖默认的publicPath设置</span></span><br><span class=\"line\">    publicPath:<span class=\"string\">'/'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果配置顺利的话，最后打包上线在页面上显示的应该就是这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=<span class=\"string\">\"css/app.ff056f366d9a3c7632b010597cbcd7ba.css\"</span> rel=<span class=\"string\">\"stylesheet\"</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这符合我们的预期，通过配置，我们也可以区别生产和开发环境，这个以后会讨论。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2017/09/19/webpack常用插件整理/timg.jpg\" alt=\"webpack常用插件整理\"></p>\n<p>webpack有很多很好用的插件，它们帮助我们日常的开发效率提高了不少，本篇博客将着重介绍一些通用的插件，适合不同框架的项目使用。</p>","more":"<h2 id=\"html-webpack-plugin\"><a href=\"#html-webpack-plugin\" class=\"headerlink\" title=\"html-webpack-plugin\"></a><mblue>html-webpack-plugin</mblue></h2><p>一个项目，不管是多页面应用还是单页面应用，都需要有<mred>html</mred>页面来承载内容，本来是一件比较容易的事，但是在<mred>webpack</mred>这个环境下，有些地方会让人觉得不是很舒服。</p>\n<h3 id=\"静态资源路径问题\"><a href=\"#静态资源路径问题\" class=\"headerlink\" title=\"静态资源路径问题\"></a>静态资源路径问题</h3><p>举个最简单的栗子，上次讲解<mred>webpack</mred>配置的时候也提过，就是开启本地服务器需要配置静态资源目录路径。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contentBase: <span class=\"string\">'/'</span> <span class=\"comment\">//默认解析静态资源的路径</span></span><br><span class=\"line\">contentBase: <span class=\"string\">'/src/'</span> <span class=\"comment\">//手动指向静态资源目录的路径</span></span><br></pre></td></tr></table></figure></p>\n<p>这是其中一个麻烦的点，不同项目还得配不同的<mred>contentBase<mred>参数。</mred></mred></p>\n<h3 id=\"不能跟随js一起打包\"><a href=\"#不能跟随js一起打包\" class=\"headerlink\" title=\"不能跟随js一起打包\"></a>不能跟随js一起打包</h3><p><mred>webpack</mred>并没有那么智能会去解<mred>index.html</mred>的路径，它的设计初衷只是为了打包js而已，也就是如果你在资源目录里创建了一个<mred>html</mred>文件，<mred>webpack</mred>并不认识，自然也就不会自动打包到对应的打包目录，单页面还好，多页面的话简直是噩梦，还要自己手动<mred>copy</mred>页面，每次打包都会清空一次打包目录，意味着要一直重复这种操作，太累了。</p>\n<h3 id=\"页面引用资源的相对路径\"><a href=\"#页面引用资源的相对路径\" class=\"headerlink\" title=\"页面引用资源的相对路径\"></a>页面引用资源的相对路径</h3><p>最绝望的是如果你原来页面写的是相对路径来访问一些静态资源，转到打包目录，结构层次不一样，路径全得改。。。不敢想下去了，大工程啊。</p>\n<h3 id=\"无法便捷的利用缓存机制\"><a href=\"#无法便捷的利用缓存机制\" class=\"headerlink\" title=\"无法便捷的利用缓存机制\"></a>无法便捷的利用缓存机制</h3><p>想有效利用缓存，最方便的就是给引入的文件后缀加<mred>hash</mred>值或者时间戳，保证该文件的唯一性，这样当浏览器去解析该文件的时候，如果之前下载过，会直接读取缓存，减少一次请求资源的操作。但是每次你改了静态资源的内容，由于你需要更新内容，不得不改变对应的<mred>hash</mred>值，然后你需要自己手动改。。太麻烦了，这样一点都不自动化。</p>\n<h3 id=\"html-webpack-plugin参数简介\"><a href=\"#html-webpack-plugin参数简介\" class=\"headerlink\" title=\"html-webpack-plugin参数简介\"></a>html-webpack-plugin参数简介</h3><p>以上的问题，我们可以通过<mred>html-webpack-plugin</mred>来进行解决，配置该插件也非常方便，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">            <span class=\"comment\">//html文件的标题</span></span><br><span class=\"line\">            title: <span class=\"string\">'My App'</span>,</span><br><span class=\"line\">            <span class=\"comment\">//简易压缩html文件的体积，去空格</span></span><br><span class=\"line\">            minify: &#123;        </span><br><span class=\"line\">                collapseWhitespace: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//会将hash值添加到每个引入的js和css文件上</span></span><br><span class=\"line\">            hash:<span class=\"literal\">true</span>, </span><br><span class=\"line\">            <span class=\"comment\">//允许生成的html页面上引入不同的chunkjs，而不是默认的入口js   </span></span><br><span class=\"line\">            chunks: [<span class=\"string\">'app'</span>, <span class=\"string\">'libs'</span>], </span><br><span class=\"line\">            <span class=\"comment\">//Webpack需要的模板的路径，用过模板文件的童鞋应该知道是干嘛的</span></span><br><span class=\"line\">            template: SRC_PATH + <span class=\"string\">'/app.ejs'</span>, </span><br><span class=\"line\">            <span class=\"comment\">//要写入HTML的文件。默认为index.html。您也可以在这里指定一个子目录（例如：assets / admin.html）。</span></span><br><span class=\"line\">            filename: <span class=\"string\">'index.html'</span>         &#125;),</span><br></pre></td></tr></table></figure>\n<p>其他一些具体的参数参考<a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\" target=\"_blank\" rel=\"noopener\"><mlink>这里</mlink></a>，对应的模板文件参考如下写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.ejs</span></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=<span class=\"string\">\"Content-type\"</span> content=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当然你直接用html文件也是一样的，剩下的<mred>html-webpack-plugin</mred>会帮你搞定的，享受自动化的构建体验吧！</p>\n<h2 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a><mblue>extract-text-webpack-plugin</mblue></h2><p>当我们开发的时候，<mred>css-loader</mred>和<mred>style-loader</mred>可以方便的把样式打包进js里面，并以<mred>style</mred>标签形式内嵌在页面上,这为我们提供了方便，因为是打包进去的，所以也支持<mred>webpack</mred>的热更新，但在生产环境下就比较尴尬了，具体有以下几个问题：</p>\n<h3 id=\"内嵌的结构不清晰，增大了页面的体积\"><a href=\"#内嵌的结构不清晰，增大了页面的体积\" class=\"headerlink\" title=\"内嵌的结构不清晰，增大了页面的体积\"></a>内嵌的结构不清晰，增大了页面的体积</h3><p>这个问题反映在比较大的项目里，<mred>css</mred>通常都会比较多，全部挤在一起，也不易维护和调试。由于是内嵌的代码也无法使用<mred>sources map</mred>，代码的优雅性也大大降低。</p>\n<h3 id=\"无法有效利用缓存机制和CDN\"><a href=\"#无法有效利用缓存机制和CDN\" class=\"headerlink\" title=\"无法有效利用缓存机制和CDN\"></a>无法有效利用缓存机制和CDN</h3><p>给文件后缀加hash或时间戳是利用缓存的常用形式，但这局限于css实体文件，<mred>CDN</mred>引流资源也是一样，内嵌的形式限制了很多功能的实现。</p>\n<h3 id=\"extract-text-webpack-plugin参数简介\"><a href=\"#extract-text-webpack-plugin参数简介\" class=\"headerlink\" title=\"extract-text-webpack-plugin参数简介\"></a>extract-text-webpack-plugin参数简介</h3><p>为了享受实体<mred>css</mred>文件的好处，我们选择了这个插件来处理<mred>css-loader</mred>处理过的<mred>css</mred>模块，下面贴出常用的一些配置属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">            <span class=\"comment\">//默认自动生成，id为此插件实例的唯一标识符</span></span><br><span class=\"line\">            id:chunkId,</span><br><span class=\"line\">            <span class=\"comment\">//输出的css文件名，可以包括[name]，[id]和[contenthash]</span></span><br><span class=\"line\">            filename: <span class=\"string\">'css/[name].[contenthash].css'</span>,</span><br><span class=\"line\">            <span class=\"comment\">//禁用插件</span></span><br><span class=\"line\">            disable: __DEV__,</span><br><span class=\"line\">            <span class=\"comment\">//从所有附加chunk中提取css文件（默认情况下，它仅从初始块中提取）， 当使用CommonsChunkPlugin并且在commons chunk中有提取的块时，allChunks必须设置为true</span></span><br><span class=\"line\">            allChunks: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n<p>这样配置只能提取纯<mred>css</mred>样式，如果我们项目中有用一些<mred>css预编译器</mred>，比如<mred>sass</mred>，<mred>less</mred>，<mred>styl</mred>等等，光这样还不够，我们还需要配置另一个方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当CSS未被提取时应该使用的loader</span></span><br><span class=\"line\">    fallback: <span class=\"string\">\"style-loader\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//将资源通过配置的loader来转换为css（必填，支持预处理器就靠这个参数）</span></span><br><span class=\"line\">    use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'sass-loader'</span>],</span><br><span class=\"line\">    <span class=\"comment\">//覆盖默认的publicPath设置</span></span><br><span class=\"line\">    publicPath:<span class=\"string\">'/'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果配置顺利的话，最后打包上线在页面上显示的应该就是这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=<span class=\"string\">\"css/app.ff056f366d9a3c7632b010597cbcd7ba.css\"</span> rel=<span class=\"string\">\"stylesheet\"</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这符合我们的预期，通过配置，我们也可以区别生产和开发环境，这个以后会讨论。</p>"},{"title":"webpack的配置解析","date":"2017-08-31T14:12:40.000Z","_content":"![webpack的配置解析](webpack的配置解析/webpack.jpg)\n\nwebpack的出现真正意义上使前端的工程化构建趋于完美，本篇将详细的讲讲webpack常用的配置选项。\n\n<!-- more -->\n\n## <mblue>webpack，browserify和RequireJs</mblue>\n<mred>webpack</mred>算是近段时间来最火的一个模块打包工具了，要说及它的优点就不得不谈谈它的前辈<mred>browserify</mred>和<mred>RequireJs</mred>。\n### <mblack>RequireJs</mblack>\n当时有一个开发人员一直头疼的问题：js有方法或属性的依赖问题，所以引入js的顺序必须严格按照依赖的先后顺序来，这为我们多次加载js造成了困难，业务复杂的情况下使维护变得非常困难。为了解决这个问题，<mred>RequireJs</mred>出现了，它使模块的加载变得井井有条。\n\n<mred>RequireJs</mred>是基于<mred>AMD</mred>规范的，也就是需要引入依赖的写法，如果写过ng1的童鞋应该对这种写法很熟悉，类似这样：\n```javascript\n//module.js 定义模块\ndefine(function () {\n    return function (a, b) {\n        console.log(a + b);\n    }\n});\n//引入\nrequire(['module'], function (module) {\n    module(1 + 2); // 3\n});\n```\n写惯了<mred>CommonJS</mred>写法的我，再回头看看这种写法，确实觉得累赘，但当时确实是一种很具有开创新的思想。<mred>RequireJs</mred>的**require**方法是一个异步方法，它可以保证在对应依赖都加载完成的情况下才执行回调函数，这使维护起来异常简便，你也不用担心加载顺序的问题，你只要关心依赖之间的关系就可以了。但这样还有个问题就是每个模块还是要引入对应的js，这样会发起多次http请求，对网页性能的影响很大，还好<mred>RequireJs</mred>提供了一个把各个模块整合到一个文件的工具，解决了多次加载文件的问题。\n\n这个时候的<mred>RequireJs</mred>已经有<mred>webpack</mred>的雏形了。\n### <mblack>browserify</mblack>\n随着<mred>node</mred>的发展，前端的工程化被不断的推上日程，其中有一个最主要的问题是工程化道路上所必须面对的：目前的浏览器还是只能支持**ES5**的语法，而<mred>node</mred>环境下模块都是用<mred>CommonJS</mred>规范构建的，怎么才能把<mred>CommonJS</mred>的语法编译成浏览器认识的**ES5**语法呢？在这探索的路上，<mred>browserify</mred>就应此出现。\n\n<mred>browserify</mred>做了两件事：\n\n1. 对用<mred>CommonJS</mred>规范构建的<mred>node</mred>模块进行转换和包装。\n2. 对<mred>node</mred>的大多数包进行了适配，使它们能更好的在浏览器里运行。\n\n保证了<mred>node</mred>模块能在浏览器顺畅运行，踏出了前端工程化的重要一步。\n### <mblack>webpack</mblack>\n<mred>webpack</mred>正是吸取了前辈的特点，将他们整合到一起，形成了一套比较完善的打包构建系统，它既有完善的打包流程，又能让<mred>node</mred>模块完美的兼容各类浏览器。\n\n随着<mred>webpack</mred>的不断发展，生态圈越来越大，渐渐成了主流的打包构建工具，前端自动化，工程化已经不再只是设想了，<mred>webpack</mred>已经帮我们实现了！\n\n## <mblue>webpack详解</mblue>\n### <mblack>webpack常见配置讲解</mblack>\n既然<mred>webpack</mred>那么好用，我们肯定要好好看看它是怎么配置的，写出适合自己项目的配置，大大提高开发效率！\n\n>注意!本人用的是<mred>webpack@2.x</mred>版本，可能会与<mred>webpack@1.x</mred>版本的有些写法会不一样，下面会提到\n\n\n[<mlink>webpack官网</mlink>](https://doc.webpack-china.org/configuration) 已经把配置选项讲解的很详细了（现在文档也有中文版的翻译了，很贴心），太细节的就不深入了，我会把一些常见的配置项拿出来，说说他们的用途和一些可能会遇到的坑，先贴一张我个人项目中部分的<mred>webpack</mred>的配置：\n```javascript\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n// 项目根路径\nconst ROOT_PATH = path.resolve(__dirname);\n// 项目源码路径\nconst SRC_PATH = ROOT_PATH + '/src';\n// 产出路径\nconst DIST_PATH = ROOT_PATH + '/dist';\n// node_modules\nconst NODE_MODULES_PATH = ROOT_PATH + '/node_modules';\nconst __DEV__ = process.env.NODE_ENV !== 'production';\nmodule.exports = {\n    devtool: 'source-map',\n    context: ROOT_PATH,\n    entry: {\n        libs: [\n            'react',\n            'react-dom',\n            'redux',\n            'react-redux',\n            'react-router',\n            'react-router-redux'\n        ],\n        app: [SRC_PATH + '/app.jsx']\n    },\n    output: {\n        path: DIST_PATH,\n        filename: __DEV__ ? 'js/[name].js' : 'js/[name].[chunkhash].js',\n        chunkFilename: __DEV__ ? 'js/[name].js' : 'js/[name].[chunkhash].js',\n        publicPath: ''\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.(jsx|js)$/,\n                include: SRC_PATH,\n                loader: 'babel-loader'\n            }]\n    },\n    resolve: {\n        modules: [SRC_PATH, \"node_modules\"],\n        alias: {\n            'react-router': NODE_MODULES_PATH + '/react-router/lib/index.js',\n            'react-redux': NODE_MODULES_PATH + '/react-redux/lib/index.js'\n        },\n        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n        extensions: ['.js', '.json', '.jsx']\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            minify: {\n                collapseWhitespace: true\n            },\n            chunks: ['app', 'libs'],\n            template: SRC_PATH + '/app.ejs'\n        }),\n        new ExtractTextPlugin({\n            filename: 'css/[name].[contenthash].css',\n            disable: __DEV__,\n            allChunks: true\n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: [\"libs\",\"manifest\"], \n            minChunks: Infinity\n        })\n    ],\n    watch: true,\n    devServer: {\n\t  contentBase: path.join(__dirname, \"dist\"),\n\t  compress: true,\n\t  port: 9000\n\t}\n}\n```\n我们不难发现，日常开发比较常用的就那么几个属性：<mred>entry</mred>、<mred>output</mred>、<mred>module</mred>、<mred>resolve</mred>、<mred>plugins</mred>、<mred>devtool</mred>，<mred>context</mred>，<mred>watch</mred>，<mred>devServer</mred>只不过根据项目的复杂度，具体的配置会有不同的变化，下面介绍一下具体每个属性的作用和对应的参数的作用。\n\n#### <mblack>entry</mblack>\n根据词意，可以知道这是入口，简而言之就是你需要打包的入口js文件，路径和名称就在这里定义的，<mred>webpack</mred>打包的时候会找到这个入口文件，然后根据入口文件写入的依赖解析路径去引入对应的模块。写法也比较灵活，可以写成以下三种形式：\n\n1. 单页面应用入口，String类型\n```javascript\nentry: \"./src/app.js\"\n```\n2. 多页面应用入口，Array类型\n```javascript\nentry: [\"./src/app1.js\",\"./src/app2.js\"]\n```\n3. 多页面应用入口，Object类型\n```javascript\nentry: {\n    chunk1: \"./src/app1.js\",\n    chunk2: \"./src/app2.js\"\n}\n```\n如果想把不同的<mred>chunk</mred>区别开来，推荐用**Object**的形式，**Object**的**key**值对应了每个<mred>chunk</mred>的名称，使结构更清晰。\n\n#### <mblack>output</mblack>\n该属性对应了打包的输出配置项，类似这样：\n```javascript\noutput: {\n    path: './dist',\n    filename:'js/[name].bundle.js',//或者'js/[id].bundle.js'、'js/[name].[hash].bundle.js'、'js/[chunkhash].bundle.js'\n    chunkFilename:'js/[name].js',\n    publicPath: '/'\n}\n```\n\n<mred>path</mred> 代表了打包后输出的目录路径，为绝对路径。\n\n<mred>filename</mred> 代表了打包输出文件的名称，对应的是从入口进入的<mred>chunk</mred>打包后的文件名，其中<mred>[name]</mred>属性会被<mred>chunk</mred>的名字替换，<mred>[id]</mred>会被模块id（chunk id）所替换，<mred>[hash]</mred>会被每次构建产生的唯一的<mred>hash</mred>值替换，<mred>[chunkhash]</mred>会被根据<mred>chunk</mred>内容生成的<mred>hash</mred>值替换。\n\n<mred>chunkFilename</mred> 是为了那些不是从标准入口进入的<mred>chunk</mred>命名用的，比较常见的就是通过<mred>CommonsChunkPlugin</mred>打包基础模块，比如<mred>react</mred>、<mred>redux</mred>这类的模块，而不是用户自己写的<mred>chunk</mred>模块，命名规则参考<mred>filename</mred>，是一样的。\n\n<mred>publicPath</mred>这个配置项是为一些外部引入的资源如（图片，文件等）设置外部访问的公共<mred>URL</mred>，为什么要这么做呢？原因其实很简单，一句话概括就是开发环境和生产环境的不同，举个栗子：\n比如你在开发环境写代码的时候你有一张图片是这么引入的\n```javascript\n// page/login/index.css\nbackground-image:'../../img/login.png'\n\n//你的目录结构\n├── app.html\n├── app.js\n├── css\n│   └── index.css\n├── img\n│   └── logo.png\n└── page\n    └── login\n        ├── index.css\n        └── login.js\n```\n之后不管你是启动本地服务器或者发布到正式环境，都会进行一次打包，不管打包进内存或到某个输出目录，你的目录结构可能就变成这样：\n```javascript\n//dist\n├── css\n│   └── app.css\n├── img\n│   └── logo.png\n└── index.html\n```\n很显然，目录的层级发生了变化，这时候你原先写的相对路径就变得不可靠了，会因找不到资源而报404，<mred>publicPath</mred>就是为了解决这个而提出的，它可以是相对路径也可以是绝对路径，以下摘一段官网的配置说明：\n```javascript\npublicPath: \"https://cdn.example.com/assets/\", // CDN（总是 HTTPS 协议）\npublicPath: \"//cdn.example.com/assets/\", // CDN (协议相同)\npublicPath: \"/assets/\", // 相对于服务(server-relative)\npublicPath: \"assets/\", // 相对于 HTML 页面\npublicPath: \"../assets/\", // 相对于 HTML 页面\npublicPath: \"\", // 相对于 HTML 页面（目录相同）\n```\n它当做相对路径写的时候可以相对于自己本身或者服务器的根目录的，所以我们之前如果设置了<mred>publicPath</mred>，比如这样：\n```javascript\npublicPath: '/img/' //相对于服务器根目录\npublicPath: '../img/' //相对于自己\n```\n那么最后我们在<mred>app.css</mred>里面看到的路径就会是这样：\n```javascript\n// app.css\nbackground-image:'/img/login.png' //相对于服务器根目录\nbackground-image:'../img/login.png' //相对于自己\n```\n怎么样，这样就很清晰了吧。这里还得提一点需要注意的，<mred> output.publicPath</mred>只是默认构建的时候的全局配置，有些<mred>loader</mred>也有自己的<mred>publicPath</mred>，这就看具体情境了，如果<mred>loader</mred>也配置了，那默认就是以<mred>loader</mred>配置的为主。\n\n>有些童鞋很惧怕这种属性，觉得和<mred>Path</mred>很像，就默认是差不多用处了，不会再去深究。这样对知识的积累很不好，记住一个原则，配置或属性只是为了给我们提供方便，没必要去惧怕它，都是为了解决某些问题而提出的，当我们明白它的用途，我们才能更好的解读配置的意义。\n\n#### <mblack>devtool</mblack>\n<mred>devtool</mred>可以让打包后的文件支持<mred>source-map</mred>，以对打包压缩后的代码进行调试，贴一张官网的配置参数图：\n```javascript\n  devtool: \"source-map\", // enum\n  devtool: \"inline-source-map\", // 嵌入到源文件中\n  devtool: \"eval-source-map\", // 将 SourceMap 嵌入到每个模块中\n  devtool: \"hidden-source-map\", // SourceMap 不在源文件中引用\n  devtool: \"cheap-source-map\", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)\n  devtool: \"cheap-module-source-map\", // 有模块映射(module mappings)的 SourceMap 低级变体\n  devtool: \"eval\", // 没有模块映射，而是命名模块。以牺牲细节达到最快。\n  // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试\n  // 牺牲了构建速度的 `source-map' 是最详细的。\n```\n#### <mblack>context</mblack>\n该配置项设置<mred>webpack</mred>的主目录<mred>entry</mred>和 <mred>module.rules.loader</mred>选项相对于此目录解析，也就是以设置的目录为基准解析路径。\n\n#### <mblack>module</mblack>\n这个选项为了处理项目中的不同类型的模块，配置也比较复杂，本文只拿常用的出来讲解，想看详细的配置说明请看[<mlink>官网</mlink>](https://doc.webpack-china.org/configuration/module)，之前注释里说的<mred>webpack</mred>不同版本的问题，这里就有体现，对于<mred>webpack@1.x</mred>版本下，<mred>module</mred>的配置可能是下面这样：\n```javascript\nmodule: {\n        loaders: [\n            {test: /\\.js$/, loader: 'babel'},\n            {test: /\\.css$/, loader: 'style!css'},\n            {test: /\\.(jpg|png|gif|svg)$/, loader: 'url?limit=8192}\n        ]\n    }\n```\n而<mred>webpack@2.x</mred>版本下，则写法统一改成这样：\n```javascript\n    module: {\n        rules: [\n            {\n                test: /\\.(jsx|js)$/,\n                include: SRC_PATH,\n                loader: 'babel-loader'\n            }]\n    }\n```\n值得一提的是，不仅写法变了，<mred>webpack@2.x</mred>以后，<mred>-loader</mred>都不能被省略，不然会报语法错误。\n\n<mred>rules</mred>是<mred>module</mred>的核心属性，它会提供一种规则数组，创建模块时，会去匹配并修改模块的创建方式。每个规则可以分为三部分<mred>条件(condition)</mred>，<mred>结果(result)</mred>和<mred>嵌套规则(nested rule)</mred>。\n\n<mred>条件(condition)</mred>很好理解，举个栗子：\n```javascript\n//app.js\nimport './css/index.css'\n```\n<mred>条件(condition)</mred>包括了被引入文件<mred>./css/index.css</mred>和导入这个文件的模块<mred>app.js</mred>两个文件的绝对路径。你也可以通过制定<mred>test</mred>的规则去匹配和筛选<mred>条件(condition)</mred>所匹配的文件流。\n\n<mred>结果(result)</mred>里面包含了一些<mred>loader</mred>，当<mred>条件(condition)</mred>满足时，会去匹配对应的被引入的文件流，对这些文件进行处理，生成对应的js模块。简单来说，对引入文件的预处理就在这里面，比如把ES6语法编译成ES5，把JSX编译成ES5，把引入的css，img转换成js模块等等。\n\n<mred>嵌套规则(nested rule)</mred>可以使用属性<mred>rules</mred>和<mred>oneOf</mred>指定嵌套规则。这些规则用于在<mred>规则条件(rule condition)</mred>匹配时进行取值。\n\n#### <mblack>resolve</mblack>\n这个选项能设置模块如何被解析，简单来说就是通过一定的规则去预定义<mred>webpack</mred>查找模块的方式，举个简单的栗子：\n比如你在<mred>app.js</mred>这样引入一个<mred>login模块</mred>\n```javascript\n//app.js\nimport login from './router/login';\n```\n如果你设置了<mred>resolve</mred>参数，比如这样：\n```javascript\n//webpack.config.js\n alias: {\n           'login':path.resolve(__dirname, 'src/router/login'),\n        }\n```\n你可以把之前的相对路径直接替换成：\n```javascript\n//app.js\nimport login from 'login';\n```\n这样写是不是简洁不少？当<mred>webpack</mred>查找<mred>login模块</mred>时，会直接根据你设置的绝对路径去查找，当层级很深的时候，再按相对路径去找明显太蠢了，这样写不仅省时，代码的可读性也更高了，下面简单介绍一下它的其他几个参数（比较常用）。\n\n<mred>extensions</mred>是用来自动解析模块扩展名的，这个懒人必备，哈哈，写法如下：\n```javascript\n//webpack.config.js\nextensions: [\".js\", \".json\",\".jsx\"]\n```\n这样你再引入模块的时候就不用写扩展名了：\n```javascript\n//app.js\nimport userList from 'login/userList.jsx'; //设置之前\nimport userList from 'login/userList'; //设置之后\n```\n设置之后，<mred>webpack</mred>再解析模块的时候会自动补全扩展名。\n\n<mred>modules</mred>告诉<mred>webpack</mred>解析模块时应该搜索的目录。默认是搜索<mred>node_modules</mred>，搜索方式类似<mred>node</mred>通过相对路径一层层往上找。当我们想让<mred>webpack</mred>搜索指定目录，提高搜索效率的时候，也可以这么写\n```javascript\n//webpack.config.js\nmodules: [path.resolve(__dirname, \"src\"), \"node_modules\"]\n```\n这样<mred>webpack</mred>会在搜索<mred>node_modules</mred>之前先搜索你指定的目录，此路径应是绝对路径。\n\n#### <mblack>plugins</mblack>\n\n<mred>plugins</mred>为<mred>webpack</mred>的插件列表，这个看具体插件，不同插件的写法不同，但都是实例化了一个对象，比如这样：\n```javascript\n plugins: [\n        new HtmlWebpackPlugin({\n            minify: {\n                collapseWhitespace: true\n            },\n            chunks: ['app', 'libs'],\n            template: SRC_PATH + '/app.ejs'\n        }),\n        new ExtractTextPlugin({\n            filename: 'css/[name].[contenthash].css',\n            disable: __DEV__,\n            allChunks: true\n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: [\"libs\",\"manifest\"], \n            minChunks: Infinity\n        })\n    ]\n```\n>善用插件可以帮我们简化开发流程，之后的博客会介绍一下比较常用<mred>webpack</mred>插件及其配置。\n\n#### <mblack>watch</mblack>\n\n<mred>watch</mred>模式意味着在初始构建之后，<mred>webpack</mred>将继续监听任何已解析文件的更改，这个配置项我们基本不用去设置，因为开了下面这个配置项是默认开启<mred>watch</mred>模式的。\n\n#### <mblack>devServer</mblack>\n\n<mred>devServer</mred>是<mred>webpack</mred>的本地服务器，它使我们的开发变的自动而高效，由于它的配置项很多，我们这里也只讲常用的几个。\n\n<mred>contentBase</mred>告诉服务器从哪里提供内容，<mred>webpack</mred>的本地服务器本质上是一个通过node启动的本地资源服务器，这里要了解个概念，通过本地服务器打包是不会生成实体文件的，而是会写进内存里面，既然没实体文件，那我们能提供的静态资源也只能是我们本地的资源文件，这就是<mred>contentBase</mred>的作用，默认是项目根目录：\n```javascript\ncontentBase: '/'\n```\n当然你也可以自定义路径，比如我有一个目录结构是这样的：\n```javascript\n.\n├── README.md\n├── node_modules\n├── package.json\n├── src\n│   ├── app.js\n│   └── index.html\n└── webpack.config.js\n```\n当你没设置<mred>contentBase</mred>时\n```javascript\ndevServer: {\n\t  compress: true,\n\t  port: 9000\n\t}\n```\n你启动本地服务器后，因为默认是项目根目录，也就是这样\n```javascript\nhttp://localhost:9000/\n```\n很显然，根目录下面没有静态资源可以加载的，我们的静态资源都在<mred>src</mred>里面，所以会出现下面的情况\n![webpack的配置解析](webpack的配置解析/error.png)\n当我们进入<mred>src</mred>里面的时候发现资源加载成功了\n![webpack的配置解析](webpack的配置解析/work.png)\n所以我们可以试着把<mred>contentBase</mred>加上\n```javascript\ndevServer: {\n     contentBase: __dirname+'/src/',\n\t  compress: true,\n\t  port: 9000\n\t}\n```\n再启动本地服务器，会看到这么一句话\n```javascript\ncontent is served from /Users/fengji/Desktop/demo/src/\n```\n代表我们设置成功了，这时候你打开9000端口可以看到这样\n![webpack的配置解析](webpack的配置解析/success.png)\n这样就请求到了我们本地资源，要是你嫌设置麻烦，推荐使用<mred>html-webpack-plugin</mred>它会帮你把资源路径正确定义到你html页面的文件夹下。\n\n<mred>compress</mred>代表是否启用<mred>gzip 压缩</mred>，推荐都设置为<mred>true</mred>，加载压缩完后的资源能加快构建速度。\n\n<mred>port</mred>为你要开启服务器的端口。\n\n<mred>inline</mred>设置为<mred>true</mred>，<mred>webpack</mred>会把一段实时刷新页面的脚本内联进你打包后的<mred>bundle</mred>文件里，你可以在控制台实时看到构建的信息。设置为<mred>flase</mred>，则用<mred>iframe</mred>内嵌html的形式构建，消息会实时显示在页面上，两种方式都可以用，个人比较偏向启用，控制台看起来直观一点。\n\n<mred>hot</mred>模式为不刷新页面的情况下进行模块的热替换，这个才是自动化构建的精髓啊，强烈推荐开启！来体验实时构建的快感吧。\n>多提一句，要开启<mred>hot</mred>模式，还需要一个插件的支持<mred>webpack.HotModuleReplacementPlugin</mred>，直接用就行了，也很方便。\n\n配置讲解差不多就这么多了，有哪里说的不对的，欢迎在底下评论，大家一起交流进步，后面可能会讲一些插件的用法，或者构建一个完整项目的流程，怎么区分生产和开发环境等等。。\n#### 备注：本篇博客皆为博主原创，转发请标明出处。\n","source":"_posts/webpack的配置解析.md","raw":"---\ntitle: webpack的配置解析\ndate: 2017-08-31 22:12:40\ntags: webpack\n---\n![webpack的配置解析](webpack的配置解析/webpack.jpg)\n\nwebpack的出现真正意义上使前端的工程化构建趋于完美，本篇将详细的讲讲webpack常用的配置选项。\n\n<!-- more -->\n\n## <mblue>webpack，browserify和RequireJs</mblue>\n<mred>webpack</mred>算是近段时间来最火的一个模块打包工具了，要说及它的优点就不得不谈谈它的前辈<mred>browserify</mred>和<mred>RequireJs</mred>。\n### <mblack>RequireJs</mblack>\n当时有一个开发人员一直头疼的问题：js有方法或属性的依赖问题，所以引入js的顺序必须严格按照依赖的先后顺序来，这为我们多次加载js造成了困难，业务复杂的情况下使维护变得非常困难。为了解决这个问题，<mred>RequireJs</mred>出现了，它使模块的加载变得井井有条。\n\n<mred>RequireJs</mred>是基于<mred>AMD</mred>规范的，也就是需要引入依赖的写法，如果写过ng1的童鞋应该对这种写法很熟悉，类似这样：\n```javascript\n//module.js 定义模块\ndefine(function () {\n    return function (a, b) {\n        console.log(a + b);\n    }\n});\n//引入\nrequire(['module'], function (module) {\n    module(1 + 2); // 3\n});\n```\n写惯了<mred>CommonJS</mred>写法的我，再回头看看这种写法，确实觉得累赘，但当时确实是一种很具有开创新的思想。<mred>RequireJs</mred>的**require**方法是一个异步方法，它可以保证在对应依赖都加载完成的情况下才执行回调函数，这使维护起来异常简便，你也不用担心加载顺序的问题，你只要关心依赖之间的关系就可以了。但这样还有个问题就是每个模块还是要引入对应的js，这样会发起多次http请求，对网页性能的影响很大，还好<mred>RequireJs</mred>提供了一个把各个模块整合到一个文件的工具，解决了多次加载文件的问题。\n\n这个时候的<mred>RequireJs</mred>已经有<mred>webpack</mred>的雏形了。\n### <mblack>browserify</mblack>\n随着<mred>node</mred>的发展，前端的工程化被不断的推上日程，其中有一个最主要的问题是工程化道路上所必须面对的：目前的浏览器还是只能支持**ES5**的语法，而<mred>node</mred>环境下模块都是用<mred>CommonJS</mred>规范构建的，怎么才能把<mred>CommonJS</mred>的语法编译成浏览器认识的**ES5**语法呢？在这探索的路上，<mred>browserify</mred>就应此出现。\n\n<mred>browserify</mred>做了两件事：\n\n1. 对用<mred>CommonJS</mred>规范构建的<mred>node</mred>模块进行转换和包装。\n2. 对<mred>node</mred>的大多数包进行了适配，使它们能更好的在浏览器里运行。\n\n保证了<mred>node</mred>模块能在浏览器顺畅运行，踏出了前端工程化的重要一步。\n### <mblack>webpack</mblack>\n<mred>webpack</mred>正是吸取了前辈的特点，将他们整合到一起，形成了一套比较完善的打包构建系统，它既有完善的打包流程，又能让<mred>node</mred>模块完美的兼容各类浏览器。\n\n随着<mred>webpack</mred>的不断发展，生态圈越来越大，渐渐成了主流的打包构建工具，前端自动化，工程化已经不再只是设想了，<mred>webpack</mred>已经帮我们实现了！\n\n## <mblue>webpack详解</mblue>\n### <mblack>webpack常见配置讲解</mblack>\n既然<mred>webpack</mred>那么好用，我们肯定要好好看看它是怎么配置的，写出适合自己项目的配置，大大提高开发效率！\n\n>注意!本人用的是<mred>webpack@2.x</mred>版本，可能会与<mred>webpack@1.x</mred>版本的有些写法会不一样，下面会提到\n\n\n[<mlink>webpack官网</mlink>](https://doc.webpack-china.org/configuration) 已经把配置选项讲解的很详细了（现在文档也有中文版的翻译了，很贴心），太细节的就不深入了，我会把一些常见的配置项拿出来，说说他们的用途和一些可能会遇到的坑，先贴一张我个人项目中部分的<mred>webpack</mred>的配置：\n```javascript\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n// 项目根路径\nconst ROOT_PATH = path.resolve(__dirname);\n// 项目源码路径\nconst SRC_PATH = ROOT_PATH + '/src';\n// 产出路径\nconst DIST_PATH = ROOT_PATH + '/dist';\n// node_modules\nconst NODE_MODULES_PATH = ROOT_PATH + '/node_modules';\nconst __DEV__ = process.env.NODE_ENV !== 'production';\nmodule.exports = {\n    devtool: 'source-map',\n    context: ROOT_PATH,\n    entry: {\n        libs: [\n            'react',\n            'react-dom',\n            'redux',\n            'react-redux',\n            'react-router',\n            'react-router-redux'\n        ],\n        app: [SRC_PATH + '/app.jsx']\n    },\n    output: {\n        path: DIST_PATH,\n        filename: __DEV__ ? 'js/[name].js' : 'js/[name].[chunkhash].js',\n        chunkFilename: __DEV__ ? 'js/[name].js' : 'js/[name].[chunkhash].js',\n        publicPath: ''\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.(jsx|js)$/,\n                include: SRC_PATH,\n                loader: 'babel-loader'\n            }]\n    },\n    resolve: {\n        modules: [SRC_PATH, \"node_modules\"],\n        alias: {\n            'react-router': NODE_MODULES_PATH + '/react-router/lib/index.js',\n            'react-redux': NODE_MODULES_PATH + '/react-redux/lib/index.js'\n        },\n        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n        extensions: ['.js', '.json', '.jsx']\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            minify: {\n                collapseWhitespace: true\n            },\n            chunks: ['app', 'libs'],\n            template: SRC_PATH + '/app.ejs'\n        }),\n        new ExtractTextPlugin({\n            filename: 'css/[name].[contenthash].css',\n            disable: __DEV__,\n            allChunks: true\n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: [\"libs\",\"manifest\"], \n            minChunks: Infinity\n        })\n    ],\n    watch: true,\n    devServer: {\n\t  contentBase: path.join(__dirname, \"dist\"),\n\t  compress: true,\n\t  port: 9000\n\t}\n}\n```\n我们不难发现，日常开发比较常用的就那么几个属性：<mred>entry</mred>、<mred>output</mred>、<mred>module</mred>、<mred>resolve</mred>、<mred>plugins</mred>、<mred>devtool</mred>，<mred>context</mred>，<mred>watch</mred>，<mred>devServer</mred>只不过根据项目的复杂度，具体的配置会有不同的变化，下面介绍一下具体每个属性的作用和对应的参数的作用。\n\n#### <mblack>entry</mblack>\n根据词意，可以知道这是入口，简而言之就是你需要打包的入口js文件，路径和名称就在这里定义的，<mred>webpack</mred>打包的时候会找到这个入口文件，然后根据入口文件写入的依赖解析路径去引入对应的模块。写法也比较灵活，可以写成以下三种形式：\n\n1. 单页面应用入口，String类型\n```javascript\nentry: \"./src/app.js\"\n```\n2. 多页面应用入口，Array类型\n```javascript\nentry: [\"./src/app1.js\",\"./src/app2.js\"]\n```\n3. 多页面应用入口，Object类型\n```javascript\nentry: {\n    chunk1: \"./src/app1.js\",\n    chunk2: \"./src/app2.js\"\n}\n```\n如果想把不同的<mred>chunk</mred>区别开来，推荐用**Object**的形式，**Object**的**key**值对应了每个<mred>chunk</mred>的名称，使结构更清晰。\n\n#### <mblack>output</mblack>\n该属性对应了打包的输出配置项，类似这样：\n```javascript\noutput: {\n    path: './dist',\n    filename:'js/[name].bundle.js',//或者'js/[id].bundle.js'、'js/[name].[hash].bundle.js'、'js/[chunkhash].bundle.js'\n    chunkFilename:'js/[name].js',\n    publicPath: '/'\n}\n```\n\n<mred>path</mred> 代表了打包后输出的目录路径，为绝对路径。\n\n<mred>filename</mred> 代表了打包输出文件的名称，对应的是从入口进入的<mred>chunk</mred>打包后的文件名，其中<mred>[name]</mred>属性会被<mred>chunk</mred>的名字替换，<mred>[id]</mred>会被模块id（chunk id）所替换，<mred>[hash]</mred>会被每次构建产生的唯一的<mred>hash</mred>值替换，<mred>[chunkhash]</mred>会被根据<mred>chunk</mred>内容生成的<mred>hash</mred>值替换。\n\n<mred>chunkFilename</mred> 是为了那些不是从标准入口进入的<mred>chunk</mred>命名用的，比较常见的就是通过<mred>CommonsChunkPlugin</mred>打包基础模块，比如<mred>react</mred>、<mred>redux</mred>这类的模块，而不是用户自己写的<mred>chunk</mred>模块，命名规则参考<mred>filename</mred>，是一样的。\n\n<mred>publicPath</mred>这个配置项是为一些外部引入的资源如（图片，文件等）设置外部访问的公共<mred>URL</mred>，为什么要这么做呢？原因其实很简单，一句话概括就是开发环境和生产环境的不同，举个栗子：\n比如你在开发环境写代码的时候你有一张图片是这么引入的\n```javascript\n// page/login/index.css\nbackground-image:'../../img/login.png'\n\n//你的目录结构\n├── app.html\n├── app.js\n├── css\n│   └── index.css\n├── img\n│   └── logo.png\n└── page\n    └── login\n        ├── index.css\n        └── login.js\n```\n之后不管你是启动本地服务器或者发布到正式环境，都会进行一次打包，不管打包进内存或到某个输出目录，你的目录结构可能就变成这样：\n```javascript\n//dist\n├── css\n│   └── app.css\n├── img\n│   └── logo.png\n└── index.html\n```\n很显然，目录的层级发生了变化，这时候你原先写的相对路径就变得不可靠了，会因找不到资源而报404，<mred>publicPath</mred>就是为了解决这个而提出的，它可以是相对路径也可以是绝对路径，以下摘一段官网的配置说明：\n```javascript\npublicPath: \"https://cdn.example.com/assets/\", // CDN（总是 HTTPS 协议）\npublicPath: \"//cdn.example.com/assets/\", // CDN (协议相同)\npublicPath: \"/assets/\", // 相对于服务(server-relative)\npublicPath: \"assets/\", // 相对于 HTML 页面\npublicPath: \"../assets/\", // 相对于 HTML 页面\npublicPath: \"\", // 相对于 HTML 页面（目录相同）\n```\n它当做相对路径写的时候可以相对于自己本身或者服务器的根目录的，所以我们之前如果设置了<mred>publicPath</mred>，比如这样：\n```javascript\npublicPath: '/img/' //相对于服务器根目录\npublicPath: '../img/' //相对于自己\n```\n那么最后我们在<mred>app.css</mred>里面看到的路径就会是这样：\n```javascript\n// app.css\nbackground-image:'/img/login.png' //相对于服务器根目录\nbackground-image:'../img/login.png' //相对于自己\n```\n怎么样，这样就很清晰了吧。这里还得提一点需要注意的，<mred> output.publicPath</mred>只是默认构建的时候的全局配置，有些<mred>loader</mred>也有自己的<mred>publicPath</mred>，这就看具体情境了，如果<mred>loader</mred>也配置了，那默认就是以<mred>loader</mred>配置的为主。\n\n>有些童鞋很惧怕这种属性，觉得和<mred>Path</mred>很像，就默认是差不多用处了，不会再去深究。这样对知识的积累很不好，记住一个原则，配置或属性只是为了给我们提供方便，没必要去惧怕它，都是为了解决某些问题而提出的，当我们明白它的用途，我们才能更好的解读配置的意义。\n\n#### <mblack>devtool</mblack>\n<mred>devtool</mred>可以让打包后的文件支持<mred>source-map</mred>，以对打包压缩后的代码进行调试，贴一张官网的配置参数图：\n```javascript\n  devtool: \"source-map\", // enum\n  devtool: \"inline-source-map\", // 嵌入到源文件中\n  devtool: \"eval-source-map\", // 将 SourceMap 嵌入到每个模块中\n  devtool: \"hidden-source-map\", // SourceMap 不在源文件中引用\n  devtool: \"cheap-source-map\", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)\n  devtool: \"cheap-module-source-map\", // 有模块映射(module mappings)的 SourceMap 低级变体\n  devtool: \"eval\", // 没有模块映射，而是命名模块。以牺牲细节达到最快。\n  // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试\n  // 牺牲了构建速度的 `source-map' 是最详细的。\n```\n#### <mblack>context</mblack>\n该配置项设置<mred>webpack</mred>的主目录<mred>entry</mred>和 <mred>module.rules.loader</mred>选项相对于此目录解析，也就是以设置的目录为基准解析路径。\n\n#### <mblack>module</mblack>\n这个选项为了处理项目中的不同类型的模块，配置也比较复杂，本文只拿常用的出来讲解，想看详细的配置说明请看[<mlink>官网</mlink>](https://doc.webpack-china.org/configuration/module)，之前注释里说的<mred>webpack</mred>不同版本的问题，这里就有体现，对于<mred>webpack@1.x</mred>版本下，<mred>module</mred>的配置可能是下面这样：\n```javascript\nmodule: {\n        loaders: [\n            {test: /\\.js$/, loader: 'babel'},\n            {test: /\\.css$/, loader: 'style!css'},\n            {test: /\\.(jpg|png|gif|svg)$/, loader: 'url?limit=8192}\n        ]\n    }\n```\n而<mred>webpack@2.x</mred>版本下，则写法统一改成这样：\n```javascript\n    module: {\n        rules: [\n            {\n                test: /\\.(jsx|js)$/,\n                include: SRC_PATH,\n                loader: 'babel-loader'\n            }]\n    }\n```\n值得一提的是，不仅写法变了，<mred>webpack@2.x</mred>以后，<mred>-loader</mred>都不能被省略，不然会报语法错误。\n\n<mred>rules</mred>是<mred>module</mred>的核心属性，它会提供一种规则数组，创建模块时，会去匹配并修改模块的创建方式。每个规则可以分为三部分<mred>条件(condition)</mred>，<mred>结果(result)</mred>和<mred>嵌套规则(nested rule)</mred>。\n\n<mred>条件(condition)</mred>很好理解，举个栗子：\n```javascript\n//app.js\nimport './css/index.css'\n```\n<mred>条件(condition)</mred>包括了被引入文件<mred>./css/index.css</mred>和导入这个文件的模块<mred>app.js</mred>两个文件的绝对路径。你也可以通过制定<mred>test</mred>的规则去匹配和筛选<mred>条件(condition)</mred>所匹配的文件流。\n\n<mred>结果(result)</mred>里面包含了一些<mred>loader</mred>，当<mred>条件(condition)</mred>满足时，会去匹配对应的被引入的文件流，对这些文件进行处理，生成对应的js模块。简单来说，对引入文件的预处理就在这里面，比如把ES6语法编译成ES5，把JSX编译成ES5，把引入的css，img转换成js模块等等。\n\n<mred>嵌套规则(nested rule)</mred>可以使用属性<mred>rules</mred>和<mred>oneOf</mred>指定嵌套规则。这些规则用于在<mred>规则条件(rule condition)</mred>匹配时进行取值。\n\n#### <mblack>resolve</mblack>\n这个选项能设置模块如何被解析，简单来说就是通过一定的规则去预定义<mred>webpack</mred>查找模块的方式，举个简单的栗子：\n比如你在<mred>app.js</mred>这样引入一个<mred>login模块</mred>\n```javascript\n//app.js\nimport login from './router/login';\n```\n如果你设置了<mred>resolve</mred>参数，比如这样：\n```javascript\n//webpack.config.js\n alias: {\n           'login':path.resolve(__dirname, 'src/router/login'),\n        }\n```\n你可以把之前的相对路径直接替换成：\n```javascript\n//app.js\nimport login from 'login';\n```\n这样写是不是简洁不少？当<mred>webpack</mred>查找<mred>login模块</mred>时，会直接根据你设置的绝对路径去查找，当层级很深的时候，再按相对路径去找明显太蠢了，这样写不仅省时，代码的可读性也更高了，下面简单介绍一下它的其他几个参数（比较常用）。\n\n<mred>extensions</mred>是用来自动解析模块扩展名的，这个懒人必备，哈哈，写法如下：\n```javascript\n//webpack.config.js\nextensions: [\".js\", \".json\",\".jsx\"]\n```\n这样你再引入模块的时候就不用写扩展名了：\n```javascript\n//app.js\nimport userList from 'login/userList.jsx'; //设置之前\nimport userList from 'login/userList'; //设置之后\n```\n设置之后，<mred>webpack</mred>再解析模块的时候会自动补全扩展名。\n\n<mred>modules</mred>告诉<mred>webpack</mred>解析模块时应该搜索的目录。默认是搜索<mred>node_modules</mred>，搜索方式类似<mred>node</mred>通过相对路径一层层往上找。当我们想让<mred>webpack</mred>搜索指定目录，提高搜索效率的时候，也可以这么写\n```javascript\n//webpack.config.js\nmodules: [path.resolve(__dirname, \"src\"), \"node_modules\"]\n```\n这样<mred>webpack</mred>会在搜索<mred>node_modules</mred>之前先搜索你指定的目录，此路径应是绝对路径。\n\n#### <mblack>plugins</mblack>\n\n<mred>plugins</mred>为<mred>webpack</mred>的插件列表，这个看具体插件，不同插件的写法不同，但都是实例化了一个对象，比如这样：\n```javascript\n plugins: [\n        new HtmlWebpackPlugin({\n            minify: {\n                collapseWhitespace: true\n            },\n            chunks: ['app', 'libs'],\n            template: SRC_PATH + '/app.ejs'\n        }),\n        new ExtractTextPlugin({\n            filename: 'css/[name].[contenthash].css',\n            disable: __DEV__,\n            allChunks: true\n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: [\"libs\",\"manifest\"], \n            minChunks: Infinity\n        })\n    ]\n```\n>善用插件可以帮我们简化开发流程，之后的博客会介绍一下比较常用<mred>webpack</mred>插件及其配置。\n\n#### <mblack>watch</mblack>\n\n<mred>watch</mred>模式意味着在初始构建之后，<mred>webpack</mred>将继续监听任何已解析文件的更改，这个配置项我们基本不用去设置，因为开了下面这个配置项是默认开启<mred>watch</mred>模式的。\n\n#### <mblack>devServer</mblack>\n\n<mred>devServer</mred>是<mred>webpack</mred>的本地服务器，它使我们的开发变的自动而高效，由于它的配置项很多，我们这里也只讲常用的几个。\n\n<mred>contentBase</mred>告诉服务器从哪里提供内容，<mred>webpack</mred>的本地服务器本质上是一个通过node启动的本地资源服务器，这里要了解个概念，通过本地服务器打包是不会生成实体文件的，而是会写进内存里面，既然没实体文件，那我们能提供的静态资源也只能是我们本地的资源文件，这就是<mred>contentBase</mred>的作用，默认是项目根目录：\n```javascript\ncontentBase: '/'\n```\n当然你也可以自定义路径，比如我有一个目录结构是这样的：\n```javascript\n.\n├── README.md\n├── node_modules\n├── package.json\n├── src\n│   ├── app.js\n│   └── index.html\n└── webpack.config.js\n```\n当你没设置<mred>contentBase</mred>时\n```javascript\ndevServer: {\n\t  compress: true,\n\t  port: 9000\n\t}\n```\n你启动本地服务器后，因为默认是项目根目录，也就是这样\n```javascript\nhttp://localhost:9000/\n```\n很显然，根目录下面没有静态资源可以加载的，我们的静态资源都在<mred>src</mred>里面，所以会出现下面的情况\n![webpack的配置解析](webpack的配置解析/error.png)\n当我们进入<mred>src</mred>里面的时候发现资源加载成功了\n![webpack的配置解析](webpack的配置解析/work.png)\n所以我们可以试着把<mred>contentBase</mred>加上\n```javascript\ndevServer: {\n     contentBase: __dirname+'/src/',\n\t  compress: true,\n\t  port: 9000\n\t}\n```\n再启动本地服务器，会看到这么一句话\n```javascript\ncontent is served from /Users/fengji/Desktop/demo/src/\n```\n代表我们设置成功了，这时候你打开9000端口可以看到这样\n![webpack的配置解析](webpack的配置解析/success.png)\n这样就请求到了我们本地资源，要是你嫌设置麻烦，推荐使用<mred>html-webpack-plugin</mred>它会帮你把资源路径正确定义到你html页面的文件夹下。\n\n<mred>compress</mred>代表是否启用<mred>gzip 压缩</mred>，推荐都设置为<mred>true</mred>，加载压缩完后的资源能加快构建速度。\n\n<mred>port</mred>为你要开启服务器的端口。\n\n<mred>inline</mred>设置为<mred>true</mred>，<mred>webpack</mred>会把一段实时刷新页面的脚本内联进你打包后的<mred>bundle</mred>文件里，你可以在控制台实时看到构建的信息。设置为<mred>flase</mred>，则用<mred>iframe</mred>内嵌html的形式构建，消息会实时显示在页面上，两种方式都可以用，个人比较偏向启用，控制台看起来直观一点。\n\n<mred>hot</mred>模式为不刷新页面的情况下进行模块的热替换，这个才是自动化构建的精髓啊，强烈推荐开启！来体验实时构建的快感吧。\n>多提一句，要开启<mred>hot</mred>模式，还需要一个插件的支持<mred>webpack.HotModuleReplacementPlugin</mred>，直接用就行了，也很方便。\n\n配置讲解差不多就这么多了，有哪里说的不对的，欢迎在底下评论，大家一起交流进步，后面可能会讲一些插件的用法，或者构建一个完整项目的流程，怎么区分生产和开发环境等等。。\n#### 备注：本篇博客皆为博主原创，转发请标明出处。\n","slug":"webpack的配置解析","published":1,"updated":"2020-01-07T02:31:54.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck53b1up500010vk5tnvbzju0","content":"<p><img src=\"/2017/08/31/webpack的配置解析/webpack.jpg\" alt=\"webpack的配置解析\"></p>\n<p>webpack的出现真正意义上使前端的工程化构建趋于完美，本篇将详细的讲讲webpack常用的配置选项。</p>\n<a id=\"more\"></a>\n<h2 id=\"webpack，browserify和RequireJs\"><a href=\"#webpack，browserify和RequireJs\" class=\"headerlink\" title=\"webpack，browserify和RequireJs\"></a><mblue>webpack，browserify和RequireJs</mblue></h2><p><mred>webpack</mred>算是近段时间来最火的一个模块打包工具了，要说及它的优点就不得不谈谈它的前辈<mred>browserify</mred>和<mred>RequireJs</mred>。</p>\n<h3 id=\"RequireJs\"><a href=\"#RequireJs\" class=\"headerlink\" title=\"RequireJs\"></a><mblack>RequireJs</mblack></h3><p>当时有一个开发人员一直头疼的问题：js有方法或属性的依赖问题，所以引入js的顺序必须严格按照依赖的先后顺序来，这为我们多次加载js造成了困难，业务复杂的情况下使维护变得非常困难。为了解决这个问题，<mred>RequireJs</mred>出现了，它使模块的加载变得井井有条。</p>\n<p><mred>RequireJs</mred>是基于<mred>AMD</mred>规范的，也就是需要引入依赖的写法，如果写过ng1的童鞋应该对这种写法很熟悉，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//module.js 定义模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//引入</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'module'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>(<span class=\"number\">1</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>写惯了<mred>CommonJS</mred>写法的我，再回头看看这种写法，确实觉得累赘，但当时确实是一种很具有开创新的思想。<mred>RequireJs</mred>的<strong>require</strong>方法是一个异步方法，它可以保证在对应依赖都加载完成的情况下才执行回调函数，这使维护起来异常简便，你也不用担心加载顺序的问题，你只要关心依赖之间的关系就可以了。但这样还有个问题就是每个模块还是要引入对应的js，这样会发起多次http请求，对网页性能的影响很大，还好<mred>RequireJs</mred>提供了一个把各个模块整合到一个文件的工具，解决了多次加载文件的问题。</p>\n<p>这个时候的<mred>RequireJs</mred>已经有<mred>webpack</mred>的雏形了。</p>\n<h3 id=\"browserify\"><a href=\"#browserify\" class=\"headerlink\" title=\"browserify\"></a><mblack>browserify</mblack></h3><p>随着<mred>node</mred>的发展，前端的工程化被不断的推上日程，其中有一个最主要的问题是工程化道路上所必须面对的：目前的浏览器还是只能支持<strong>ES5</strong>的语法，而<mred>node</mred>环境下模块都是用<mred>CommonJS</mred>规范构建的，怎么才能把<mred>CommonJS</mred>的语法编译成浏览器认识的<strong>ES5</strong>语法呢？在这探索的路上，<mred>browserify</mred>就应此出现。</p>\n<p><mred>browserify</mred>做了两件事：</p>\n<ol>\n<li>对用<mred>CommonJS</mred>规范构建的<mred>node</mred>模块进行转换和包装。</li>\n<li>对<mred>node</mred>的大多数包进行了适配，使它们能更好的在浏览器里运行。</li>\n</ol>\n<p>保证了<mred>node</mred>模块能在浏览器顺畅运行，踏出了前端工程化的重要一步。</p>\n<h3 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a><mblack>webpack</mblack></h3><p><mred>webpack</mred>正是吸取了前辈的特点，将他们整合到一起，形成了一套比较完善的打包构建系统，它既有完善的打包流程，又能让<mred>node</mred>模块完美的兼容各类浏览器。</p>\n<p>随着<mred>webpack</mred>的不断发展，生态圈越来越大，渐渐成了主流的打包构建工具，前端自动化，工程化已经不再只是设想了，<mred>webpack</mred>已经帮我们实现了！</p>\n<h2 id=\"webpack详解\"><a href=\"#webpack详解\" class=\"headerlink\" title=\"webpack详解\"></a><mblue>webpack详解</mblue></h2><h3 id=\"webpack常见配置讲解\"><a href=\"#webpack常见配置讲解\" class=\"headerlink\" title=\"webpack常见配置讲解\"></a><mblack>webpack常见配置讲解</mblack></h3><p>既然<mred>webpack</mred>那么好用，我们肯定要好好看看它是怎么配置的，写出适合自己项目的配置，大大提高开发效率！</p>\n<blockquote>\n<p>注意!本人用的是<mred><a href=\"mailto:webpack@2.x\" target=\"_blank\" rel=\"noopener\">webpack@2.x</a></mred>版本，可能会与<mred><a href=\"mailto:webpack@1.x\" target=\"_blank\" rel=\"noopener\">webpack@1.x</a></mred>版本的有些写法会不一样，下面会提到</p>\n</blockquote>\n<p><a href=\"https://doc.webpack-china.org/configuration\" target=\"_blank\" rel=\"noopener\"><mlink>webpack官网</mlink></a> 已经把配置选项讲解的很详细了（现在文档也有中文版的翻译了，很贴心），太细节的就不深入了，我会把一些常见的配置项拿出来，说说他们的用途和一些可能会遇到的坑，先贴一张我个人项目中部分的<mred>webpack</mred>的配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 项目根路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ROOT_PATH = path.resolve(__dirname);</span><br><span class=\"line\"><span class=\"comment\">// 项目源码路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> SRC_PATH = ROOT_PATH + <span class=\"string\">'/src'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 产出路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> DIST_PATH = ROOT_PATH + <span class=\"string\">'/dist'</span>;</span><br><span class=\"line\"><span class=\"comment\">// node_modules</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> NODE_MODULES_PATH = ROOT_PATH + <span class=\"string\">'/node_modules'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> __DEV__ = process.env.NODE_ENV !== <span class=\"string\">'production'</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    devtool: <span class=\"string\">'source-map'</span>,</span><br><span class=\"line\">    context: ROOT_PATH,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        libs: [</span><br><span class=\"line\">            <span class=\"string\">'react'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-dom'</span>,</span><br><span class=\"line\">            <span class=\"string\">'redux'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-redux'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-router'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-router-redux'</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        app: [SRC_PATH + <span class=\"string\">'/app.jsx'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: DIST_PATH,</span><br><span class=\"line\">        filename: __DEV__ ? <span class=\"string\">'js/[name].js'</span> : <span class=\"string\">'js/[name].[chunkhash].js'</span>,</span><br><span class=\"line\">        chunkFilename: __DEV__ ? <span class=\"string\">'js/[name].js'</span> : <span class=\"string\">'js/[name].[chunkhash].js'</span>,</span><br><span class=\"line\">        publicPath: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: <span class=\"regexp\">/\\.(jsx|js)$/</span>,</span><br><span class=\"line\">                include: SRC_PATH,</span><br><span class=\"line\">                loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">            &#125;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">        modules: [SRC_PATH, <span class=\"string\">\"node_modules\"</span>],</span><br><span class=\"line\">        alias: &#123;</span><br><span class=\"line\">            <span class=\"string\">'react-router'</span>: NODE_MODULES_PATH + <span class=\"string\">'/react-router/lib/index.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-redux'</span>: NODE_MODULES_PATH + <span class=\"string\">'/react-redux/lib/index.js'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class=\"line\">        extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">            minify: &#123;</span><br><span class=\"line\">                collapseWhitespace: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            chunks: [<span class=\"string\">'app'</span>, <span class=\"string\">'libs'</span>],</span><br><span class=\"line\">            template: SRC_PATH + <span class=\"string\">'/app.ejs'</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">            filename: <span class=\"string\">'css/[name].[contenthash].css'</span>,</span><br><span class=\"line\">            disable: __DEV__,</span><br><span class=\"line\">            allChunks: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">            name: [<span class=\"string\">\"libs\"</span>,<span class=\"string\">\"manifest\"</span>], </span><br><span class=\"line\">            minChunks: <span class=\"literal\">Infinity</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    watch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">\t  contentBase: path.join(__dirname, <span class=\"string\">\"dist\"</span>),</span><br><span class=\"line\">\t  compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t  port: <span class=\"number\">9000</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们不难发现，日常开发比较常用的就那么几个属性：<mred>entry</mred>、<mred>output</mred>、<mred>module</mred>、<mred>resolve</mred>、<mred>plugins</mred>、<mred>devtool</mred>，<mred>context</mred>，<mred>watch</mred>，<mred>devServer</mred>只不过根据项目的复杂度，具体的配置会有不同的变化，下面介绍一下具体每个属性的作用和对应的参数的作用。</p>\n<h4 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a><mblack>entry</mblack></h4><p>根据词意，可以知道这是入口，简而言之就是你需要打包的入口js文件，路径和名称就在这里定义的，<mred>webpack</mred>打包的时候会找到这个入口文件，然后根据入口文件写入的依赖解析路径去引入对应的模块。写法也比较灵活，可以写成以下三种形式：</p>\n<ol>\n<li><p>单页面应用入口，String类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: <span class=\"string\">\"./src/app.js\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多页面应用入口，Array类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: [<span class=\"string\">\"./src/app1.js\"</span>,<span class=\"string\">\"./src/app2.js\"</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多页面应用入口，Object类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    chunk1: <span class=\"string\">\"./src/app1.js\"</span>,</span><br><span class=\"line\">    chunk2: <span class=\"string\">\"./src/app2.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果想把不同的<mred>chunk</mred>区别开来，推荐用<strong>Object</strong>的形式，<strong>Object</strong>的<strong>key</strong>值对应了每个<mred>chunk</mred>的名称，使结构更清晰。</p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a><mblack>output</mblack></h4><p>该属性对应了打包的输出配置项，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: <span class=\"string\">'./dist'</span>,</span><br><span class=\"line\">    filename:<span class=\"string\">'js/[name].bundle.js'</span>,<span class=\"comment\">//或者'js/[id].bundle.js'、'js/[name].[hash].bundle.js'、'js/[chunkhash].bundle.js'</span></span><br><span class=\"line\">    chunkFilename:<span class=\"string\">'js/[name].js'</span>,</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><mred>path</mred> 代表了打包后输出的目录路径，为绝对路径。</p>\n<p><mred>filename</mred> 代表了打包输出文件的名称，对应的是从入口进入的<mred>chunk</mred>打包后的文件名，其中<mred>[name]</mred>属性会被<mred>chunk</mred>的名字替换，<mred>[id]</mred>会被模块id（chunk id）所替换，<mred>[hash]</mred>会被每次构建产生的唯一的<mred>hash</mred>值替换，<mred>[chunkhash]</mred>会被根据<mred>chunk</mred>内容生成的<mred>hash</mred>值替换。</p>\n<p><mred>chunkFilename</mred> 是为了那些不是从标准入口进入的<mred>chunk</mred>命名用的，比较常见的就是通过<mred>CommonsChunkPlugin</mred>打包基础模块，比如<mred>react</mred>、<mred>redux</mred>这类的模块，而不是用户自己写的<mred>chunk</mred>模块，命名规则参考<mred>filename</mred>，是一样的。</p>\n<p><mred>publicPath</mred>这个配置项是为一些外部引入的资源如（图片，文件等）设置外部访问的公共<mred>URL</mred>，为什么要这么做呢？原因其实很简单，一句话概括就是开发环境和生产环境的不同，举个栗子：<br>比如你在开发环境写代码的时候你有一张图片是这么引入的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// page/login/index.css</span></span><br><span class=\"line\">background-image:<span class=\"string\">'../../img/login.png'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//你的目录结构</span></span><br><span class=\"line\">├── app.html</span><br><span class=\"line\">├── app.js</span><br><span class=\"line\">├── css</span><br><span class=\"line\">│   └── index.css</span><br><span class=\"line\">├── img</span><br><span class=\"line\">│   └── logo.png</span><br><span class=\"line\">└── page</span><br><span class=\"line\">    └── login</span><br><span class=\"line\">        ├── index.css</span><br><span class=\"line\">        └── login.js</span><br></pre></td></tr></table></figure></p>\n<p>之后不管你是启动本地服务器或者发布到正式环境，都会进行一次打包，不管打包进内存或到某个输出目录，你的目录结构可能就变成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dist</span></span><br><span class=\"line\">├── css</span><br><span class=\"line\">│   └── app.css</span><br><span class=\"line\">├── img</span><br><span class=\"line\">│   └── logo.png</span><br><span class=\"line\">└── index.html</span><br></pre></td></tr></table></figure></p>\n<p>很显然，目录的层级发生了变化，这时候你原先写的相对路径就变得不可靠了，会因找不到资源而报404，<mred>publicPath</mred>就是为了解决这个而提出的，它可以是相对路径也可以是绝对路径，以下摘一段官网的配置说明：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">publicPath: <span class=\"string\">\"https://cdn.example.com/assets/\"</span>, <span class=\"comment\">// CDN（总是 HTTPS 协议）</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"//cdn.example.com/assets/\"</span>, <span class=\"comment\">// CDN (协议相同)</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"/assets/\"</span>, <span class=\"comment\">// 相对于服务(server-relative)</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"assets/\"</span>, <span class=\"comment\">// 相对于 HTML 页面</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"../assets/\"</span>, <span class=\"comment\">// 相对于 HTML 页面</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"\"</span>, <span class=\"comment\">// 相对于 HTML 页面（目录相同）</span></span><br></pre></td></tr></table></figure></p>\n<p>它当做相对路径写的时候可以相对于自己本身或者服务器的根目录的，所以我们之前如果设置了<mred>publicPath</mred>，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">publicPath: <span class=\"string\">'/img/'</span> <span class=\"comment\">//相对于服务器根目录</span></span><br><span class=\"line\">publicPath: <span class=\"string\">'../img/'</span> <span class=\"comment\">//相对于自己</span></span><br></pre></td></tr></table></figure></p>\n<p>那么最后我们在<mred>app.css</mred>里面看到的路径就会是这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.css</span></span><br><span class=\"line\">background-image:<span class=\"string\">'/img/login.png'</span> <span class=\"comment\">//相对于服务器根目录</span></span><br><span class=\"line\">background-image:<span class=\"string\">'../img/login.png'</span> <span class=\"comment\">//相对于自己</span></span><br></pre></td></tr></table></figure></p>\n<p>怎么样，这样就很清晰了吧。这里还得提一点需要注意的，<mred> output.publicPath</mred>只是默认构建的时候的全局配置，有些<mred>loader</mred>也有自己的<mred>publicPath</mred>，这就看具体情境了，如果<mred>loader</mred>也配置了，那默认就是以<mred>loader</mred>配置的为主。</p>\n<blockquote>\n<p>有些童鞋很惧怕这种属性，觉得和<mred>Path</mred>很像，就默认是差不多用处了，不会再去深究。这样对知识的积累很不好，记住一个原则，配置或属性只是为了给我们提供方便，没必要去惧怕它，都是为了解决某些问题而提出的，当我们明白它的用途，我们才能更好的解读配置的意义。</p>\n</blockquote>\n<h4 id=\"devtool\"><a href=\"#devtool\" class=\"headerlink\" title=\"devtool\"></a><mblack>devtool</mblack></h4><p><mred>devtool</mred>可以让打包后的文件支持<mred>source-map</mred>，以对打包压缩后的代码进行调试，贴一张官网的配置参数图：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtool: <span class=\"string\">\"source-map\"</span>, <span class=\"comment\">// enum</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"inline-source-map\"</span>, <span class=\"comment\">// 嵌入到源文件中</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"eval-source-map\"</span>, <span class=\"comment\">// 将 SourceMap 嵌入到每个模块中</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"hidden-source-map\"</span>, <span class=\"comment\">// SourceMap 不在源文件中引用</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"cheap-source-map\"</span>, <span class=\"comment\">// 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"cheap-module-source-map\"</span>, <span class=\"comment\">// 有模块映射(module mappings)的 SourceMap 低级变体</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"eval\"</span>, <span class=\"comment\">// 没有模块映射，而是命名模块。以牺牲细节达到最快。</span></span><br><span class=\"line\"><span class=\"comment\">// 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试</span></span><br><span class=\"line\"><span class=\"comment\">// 牺牲了构建速度的 `source-map' 是最详细的。</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a><mblack>context</mblack></h4><p>该配置项设置<mred>webpack</mred>的主目录<mred>entry</mred>和 <mred>module.rules.loader</mred>选项相对于此目录解析，也就是以设置的目录为基准解析路径。</p>\n<h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a><mblack>module</mblack></h4><p>这个选项为了处理项目中的不同类型的模块，配置也比较复杂，本文只拿常用的出来讲解，想看详细的配置说明请看<a href=\"https://doc.webpack-china.org/configuration/module\" target=\"_blank\" rel=\"noopener\"><mlink>官网</mlink></a>，之前注释里说的<mred>webpack</mred>不同版本的问题，这里就有体现，对于<mred><a href=\"mailto:webpack@1.x\" target=\"_blank\" rel=\"noopener\">webpack@1.x</a></mred>版本下，<mred>module</mred>的配置可能是下面这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;<span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css'</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(jpg|png|gif|svg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url?limit=8192&#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>而<mred><a href=\"mailto:webpack@2.x\" target=\"_blank\" rel=\"noopener\">webpack@2.x</a></mred>版本下，则写法统一改成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.(jsx|js)$/</span>,</span><br><span class=\"line\">            include: SRC_PATH,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>值得一提的是，不仅写法变了，<mred><a href=\"mailto:webpack@2.x\" target=\"_blank\" rel=\"noopener\">webpack@2.x</a></mred>以后，<mred>-loader</mred>都不能被省略，不然会报语法错误。</p>\n<p><mred>rules</mred>是<mred>module</mred>的核心属性，它会提供一种规则数组，创建模块时，会去匹配并修改模块的创建方式。每个规则可以分为三部分<mred>条件(condition)</mred>，<mred>结果(result)</mred>和<mred>嵌套规则(nested rule)</mred>。</p>\n<p><mred>条件(condition)</mred>很好理解，举个栗子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./css/index.css'</span></span><br></pre></td></tr></table></figure></p>\n<p><mred>条件(condition)</mred>包括了被引入文件<mred>./css/index.css</mred>和导入这个文件的模块<mred>app.js</mred>两个文件的绝对路径。你也可以通过制定<mred>test</mred>的规则去匹配和筛选<mred>条件(condition)</mred>所匹配的文件流。</p>\n<p><mred>结果(result)</mred>里面包含了一些<mred>loader</mred>，当<mred>条件(condition)</mred>满足时，会去匹配对应的被引入的文件流，对这些文件进行处理，生成对应的js模块。简单来说，对引入文件的预处理就在这里面，比如把ES6语法编译成ES5，把JSX编译成ES5，把引入的css，img转换成js模块等等。</p>\n<p><mred>嵌套规则(nested rule)</mred>可以使用属性<mred>rules</mred>和<mred>oneOf</mred>指定嵌套规则。这些规则用于在<mred>规则条件(rule condition)</mred>匹配时进行取值。</p>\n<h4 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve\"></a><mblack>resolve</mblack></h4><p>这个选项能设置模块如何被解析，简单来说就是通过一定的规则去预定义<mred>webpack</mred>查找模块的方式，举个简单的栗子：<br>比如你在<mred>app.js</mred>这样引入一个<mred>login模块</mred><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> login <span class=\"keyword\">from</span> <span class=\"string\">'./router/login'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>如果你设置了<mred>resolve</mred>参数，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.js</span></span><br><span class=\"line\"> alias: &#123;</span><br><span class=\"line\">           <span class=\"string\">'login'</span>:path.resolve(__dirname, <span class=\"string\">'src/router/login'</span>),</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以把之前的相对路径直接替换成：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> login <span class=\"keyword\">from</span> <span class=\"string\">'login'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样写是不是简洁不少？当<mred>webpack</mred>查找<mred>login模块</mred>时，会直接根据你设置的绝对路径去查找，当层级很深的时候，再按相对路径去找明显太蠢了，这样写不仅省时，代码的可读性也更高了，下面简单介绍一下它的其他几个参数（比较常用）。</p>\n<p><mred>extensions</mred>是用来自动解析模块扩展名的，这个懒人必备，哈哈，写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.js</span></span><br><span class=\"line\">extensions: [<span class=\"string\">\".js\"</span>, <span class=\"string\">\".json\"</span>,<span class=\"string\">\".jsx\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>这样你再引入模块的时候就不用写扩展名了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> userList <span class=\"keyword\">from</span> <span class=\"string\">'login/userList.jsx'</span>; <span class=\"comment\">//设置之前</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> userList <span class=\"keyword\">from</span> <span class=\"string\">'login/userList'</span>; <span class=\"comment\">//设置之后</span></span><br></pre></td></tr></table></figure></p>\n<p>设置之后，<mred>webpack</mred>再解析模块的时候会自动补全扩展名。</p>\n<p><mred>modules</mred>告诉<mred>webpack</mred>解析模块时应该搜索的目录。默认是搜索<mred>node_modules</mred>，搜索方式类似<mred>node</mred>通过相对路径一层层往上找。当我们想让<mred>webpack</mred>搜索指定目录，提高搜索效率的时候，也可以这么写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.js</span></span><br><span class=\"line\">modules: [path.resolve(__dirname, <span class=\"string\">\"src\"</span>), <span class=\"string\">\"node_modules\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>这样<mred>webpack</mred>会在搜索<mred>node_modules</mred>之前先搜索你指定的目录，此路径应是绝对路径。</p>\n<h4 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a><mblack>plugins</mblack></h4><p><mred>plugins</mred>为<mred>webpack</mred>的插件列表，这个看具体插件，不同插件的写法不同，但都是实例化了一个对象，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">       <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">           minify: &#123;</span><br><span class=\"line\">               collapseWhitespace: <span class=\"literal\">true</span></span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           chunks: [<span class=\"string\">'app'</span>, <span class=\"string\">'libs'</span>],</span><br><span class=\"line\">           template: SRC_PATH + <span class=\"string\">'/app.ejs'</span></span><br><span class=\"line\">       &#125;),</span><br><span class=\"line\">       <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">           filename: <span class=\"string\">'css/[name].[contenthash].css'</span>,</span><br><span class=\"line\">           disable: __DEV__,</span><br><span class=\"line\">           allChunks: <span class=\"literal\">true</span></span><br><span class=\"line\">       &#125;),</span><br><span class=\"line\">       <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">           name: [<span class=\"string\">\"libs\"</span>,<span class=\"string\">\"manifest\"</span>], </span><br><span class=\"line\">           minChunks: <span class=\"literal\">Infinity</span></span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">   ]</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>善用插件可以帮我们简化开发流程，之后的博客会介绍一下比较常用<mred>webpack</mred>插件及其配置。</p>\n</blockquote>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a><mblack>watch</mblack></h4><p><mred>watch</mred>模式意味着在初始构建之后，<mred>webpack</mred>将继续监听任何已解析文件的更改，这个配置项我们基本不用去设置，因为开了下面这个配置项是默认开启<mred>watch</mred>模式的。</p>\n<h4 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a><mblack>devServer</mblack></h4><p><mred>devServer</mred>是<mred>webpack</mred>的本地服务器，它使我们的开发变的自动而高效，由于它的配置项很多，我们这里也只讲常用的几个。</p>\n<p><mred>contentBase</mred>告诉服务器从哪里提供内容，<mred>webpack</mred>的本地服务器本质上是一个通过node启动的本地资源服务器，这里要了解个概念，通过本地服务器打包是不会生成实体文件的，而是会写进内存里面，既然没实体文件，那我们能提供的静态资源也只能是我们本地的资源文件，这就是<mred>contentBase</mred>的作用，默认是项目根目录：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contentBase: <span class=\"string\">'/'</span></span><br></pre></td></tr></table></figure></p>\n<p>当然你也可以自定义路径，比如我有一个目录结构是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── app.js</span><br><span class=\"line\">│   └── index.html</span><br><span class=\"line\">└── webpack.config.js</span><br></pre></td></tr></table></figure></p>\n<p>当你没设置<mred>contentBase</mred>时<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">\t  compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t  port: <span class=\"number\">9000</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你启动本地服务器后，因为默认是项目根目录，也就是这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//localhost:9000/</span></span><br></pre></td></tr></table></figure></p>\n<p>很显然，根目录下面没有静态资源可以加载的，我们的静态资源都在<mred>src</mred>里面，所以会出现下面的情况<br><img src=\"/2017/08/31/webpack的配置解析/error.png\" alt=\"webpack的配置解析\"><br>当我们进入<mred>src</mred>里面的时候发现资源加载成功了<br><img src=\"/2017/08/31/webpack的配置解析/work.png\" alt=\"webpack的配置解析\"><br>所以我们可以试着把<mred>contentBase</mred>加上<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">     contentBase: __dirname+<span class=\"string\">'/src/'</span>,</span><br><span class=\"line\">\t  compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t  port: <span class=\"number\">9000</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再启动本地服务器，会看到这么一句话<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content is served <span class=\"keyword\">from</span> /Users/fengji/Desktop/demo/src/</span><br></pre></td></tr></table></figure></p>\n<p>代表我们设置成功了，这时候你打开9000端口可以看到这样<br><img src=\"/2017/08/31/webpack的配置解析/success.png\" alt=\"webpack的配置解析\"><br>这样就请求到了我们本地资源，要是你嫌设置麻烦，推荐使用<mred>html-webpack-plugin</mred>它会帮你把资源路径正确定义到你html页面的文件夹下。</p>\n<p><mred>compress</mred>代表是否启用<mred>gzip 压缩</mred>，推荐都设置为<mred>true</mred>，加载压缩完后的资源能加快构建速度。</p>\n<p><mred>port</mred>为你要开启服务器的端口。</p>\n<p><mred>inline</mred>设置为<mred>true</mred>，<mred>webpack</mred>会把一段实时刷新页面的脚本内联进你打包后的<mred>bundle</mred>文件里，你可以在控制台实时看到构建的信息。设置为<mred>flase</mred>，则用<mred>iframe</mred>内嵌html的形式构建，消息会实时显示在页面上，两种方式都可以用，个人比较偏向启用，控制台看起来直观一点。</p>\n<p><mred>hot</mred>模式为不刷新页面的情况下进行模块的热替换，这个才是自动化构建的精髓啊，强烈推荐开启！来体验实时构建的快感吧。</p>\n<blockquote>\n<p>多提一句，要开启<mred>hot</mred>模式，还需要一个插件的支持<mred>webpack.HotModuleReplacementPlugin</mred>，直接用就行了，也很方便。</p>\n</blockquote>\n<p>配置讲解差不多就这么多了，有哪里说的不对的，欢迎在底下评论，大家一起交流进步，后面可能会讲一些插件的用法，或者构建一个完整项目的流程，怎么区分生产和开发环境等等。。</p>\n<h4 id=\"备注：本篇博客皆为博主原创，转发请标明出处。\"><a href=\"#备注：本篇博客皆为博主原创，转发请标明出处。\" class=\"headerlink\" title=\"备注：本篇博客皆为博主原创，转发请标明出处。\"></a>备注：本篇博客皆为博主原创，转发请标明出处。</h4>","site":{"data":{}},"excerpt":"<p><img src=\"/2017/08/31/webpack的配置解析/webpack.jpg\" alt=\"webpack的配置解析\"></p>\n<p>webpack的出现真正意义上使前端的工程化构建趋于完美，本篇将详细的讲讲webpack常用的配置选项。</p>","more":"<h2 id=\"webpack，browserify和RequireJs\"><a href=\"#webpack，browserify和RequireJs\" class=\"headerlink\" title=\"webpack，browserify和RequireJs\"></a><mblue>webpack，browserify和RequireJs</mblue></h2><p><mred>webpack</mred>算是近段时间来最火的一个模块打包工具了，要说及它的优点就不得不谈谈它的前辈<mred>browserify</mred>和<mred>RequireJs</mred>。</p>\n<h3 id=\"RequireJs\"><a href=\"#RequireJs\" class=\"headerlink\" title=\"RequireJs\"></a><mblack>RequireJs</mblack></h3><p>当时有一个开发人员一直头疼的问题：js有方法或属性的依赖问题，所以引入js的顺序必须严格按照依赖的先后顺序来，这为我们多次加载js造成了困难，业务复杂的情况下使维护变得非常困难。为了解决这个问题，<mred>RequireJs</mred>出现了，它使模块的加载变得井井有条。</p>\n<p><mred>RequireJs</mred>是基于<mred>AMD</mred>规范的，也就是需要引入依赖的写法，如果写过ng1的童鞋应该对这种写法很熟悉，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//module.js 定义模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//引入</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'module'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>(<span class=\"number\">1</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>写惯了<mred>CommonJS</mred>写法的我，再回头看看这种写法，确实觉得累赘，但当时确实是一种很具有开创新的思想。<mred>RequireJs</mred>的<strong>require</strong>方法是一个异步方法，它可以保证在对应依赖都加载完成的情况下才执行回调函数，这使维护起来异常简便，你也不用担心加载顺序的问题，你只要关心依赖之间的关系就可以了。但这样还有个问题就是每个模块还是要引入对应的js，这样会发起多次http请求，对网页性能的影响很大，还好<mred>RequireJs</mred>提供了一个把各个模块整合到一个文件的工具，解决了多次加载文件的问题。</p>\n<p>这个时候的<mred>RequireJs</mred>已经有<mred>webpack</mred>的雏形了。</p>\n<h3 id=\"browserify\"><a href=\"#browserify\" class=\"headerlink\" title=\"browserify\"></a><mblack>browserify</mblack></h3><p>随着<mred>node</mred>的发展，前端的工程化被不断的推上日程，其中有一个最主要的问题是工程化道路上所必须面对的：目前的浏览器还是只能支持<strong>ES5</strong>的语法，而<mred>node</mred>环境下模块都是用<mred>CommonJS</mred>规范构建的，怎么才能把<mred>CommonJS</mred>的语法编译成浏览器认识的<strong>ES5</strong>语法呢？在这探索的路上，<mred>browserify</mred>就应此出现。</p>\n<p><mred>browserify</mred>做了两件事：</p>\n<ol>\n<li>对用<mred>CommonJS</mred>规范构建的<mred>node</mred>模块进行转换和包装。</li>\n<li>对<mred>node</mred>的大多数包进行了适配，使它们能更好的在浏览器里运行。</li>\n</ol>\n<p>保证了<mred>node</mred>模块能在浏览器顺畅运行，踏出了前端工程化的重要一步。</p>\n<h3 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a><mblack>webpack</mblack></h3><p><mred>webpack</mred>正是吸取了前辈的特点，将他们整合到一起，形成了一套比较完善的打包构建系统，它既有完善的打包流程，又能让<mred>node</mred>模块完美的兼容各类浏览器。</p>\n<p>随着<mred>webpack</mred>的不断发展，生态圈越来越大，渐渐成了主流的打包构建工具，前端自动化，工程化已经不再只是设想了，<mred>webpack</mred>已经帮我们实现了！</p>\n<h2 id=\"webpack详解\"><a href=\"#webpack详解\" class=\"headerlink\" title=\"webpack详解\"></a><mblue>webpack详解</mblue></h2><h3 id=\"webpack常见配置讲解\"><a href=\"#webpack常见配置讲解\" class=\"headerlink\" title=\"webpack常见配置讲解\"></a><mblack>webpack常见配置讲解</mblack></h3><p>既然<mred>webpack</mred>那么好用，我们肯定要好好看看它是怎么配置的，写出适合自己项目的配置，大大提高开发效率！</p>\n<blockquote>\n<p>注意!本人用的是<mred><a href=\"mailto:webpack@2.x\" target=\"_blank\" rel=\"noopener\">webpack@2.x</a></mred>版本，可能会与<mred><a href=\"mailto:webpack@1.x\" target=\"_blank\" rel=\"noopener\">webpack@1.x</a></mred>版本的有些写法会不一样，下面会提到</p>\n</blockquote>\n<p><a href=\"https://doc.webpack-china.org/configuration\" target=\"_blank\" rel=\"noopener\"><mlink>webpack官网</mlink></a> 已经把配置选项讲解的很详细了（现在文档也有中文版的翻译了，很贴心），太细节的就不深入了，我会把一些常见的配置项拿出来，说说他们的用途和一些可能会遇到的坑，先贴一张我个人项目中部分的<mred>webpack</mred>的配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 项目根路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ROOT_PATH = path.resolve(__dirname);</span><br><span class=\"line\"><span class=\"comment\">// 项目源码路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> SRC_PATH = ROOT_PATH + <span class=\"string\">'/src'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 产出路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> DIST_PATH = ROOT_PATH + <span class=\"string\">'/dist'</span>;</span><br><span class=\"line\"><span class=\"comment\">// node_modules</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> NODE_MODULES_PATH = ROOT_PATH + <span class=\"string\">'/node_modules'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> __DEV__ = process.env.NODE_ENV !== <span class=\"string\">'production'</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    devtool: <span class=\"string\">'source-map'</span>,</span><br><span class=\"line\">    context: ROOT_PATH,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        libs: [</span><br><span class=\"line\">            <span class=\"string\">'react'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-dom'</span>,</span><br><span class=\"line\">            <span class=\"string\">'redux'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-redux'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-router'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-router-redux'</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        app: [SRC_PATH + <span class=\"string\">'/app.jsx'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: DIST_PATH,</span><br><span class=\"line\">        filename: __DEV__ ? <span class=\"string\">'js/[name].js'</span> : <span class=\"string\">'js/[name].[chunkhash].js'</span>,</span><br><span class=\"line\">        chunkFilename: __DEV__ ? <span class=\"string\">'js/[name].js'</span> : <span class=\"string\">'js/[name].[chunkhash].js'</span>,</span><br><span class=\"line\">        publicPath: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: <span class=\"regexp\">/\\.(jsx|js)$/</span>,</span><br><span class=\"line\">                include: SRC_PATH,</span><br><span class=\"line\">                loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">            &#125;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">        modules: [SRC_PATH, <span class=\"string\">\"node_modules\"</span>],</span><br><span class=\"line\">        alias: &#123;</span><br><span class=\"line\">            <span class=\"string\">'react-router'</span>: NODE_MODULES_PATH + <span class=\"string\">'/react-router/lib/index.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'react-redux'</span>: NODE_MODULES_PATH + <span class=\"string\">'/react-redux/lib/index.js'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class=\"line\">        extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">            minify: &#123;</span><br><span class=\"line\">                collapseWhitespace: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            chunks: [<span class=\"string\">'app'</span>, <span class=\"string\">'libs'</span>],</span><br><span class=\"line\">            template: SRC_PATH + <span class=\"string\">'/app.ejs'</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">            filename: <span class=\"string\">'css/[name].[contenthash].css'</span>,</span><br><span class=\"line\">            disable: __DEV__,</span><br><span class=\"line\">            allChunks: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">            name: [<span class=\"string\">\"libs\"</span>,<span class=\"string\">\"manifest\"</span>], </span><br><span class=\"line\">            minChunks: <span class=\"literal\">Infinity</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    watch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">\t  contentBase: path.join(__dirname, <span class=\"string\">\"dist\"</span>),</span><br><span class=\"line\">\t  compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t  port: <span class=\"number\">9000</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们不难发现，日常开发比较常用的就那么几个属性：<mred>entry</mred>、<mred>output</mred>、<mred>module</mred>、<mred>resolve</mred>、<mred>plugins</mred>、<mred>devtool</mred>，<mred>context</mred>，<mred>watch</mred>，<mred>devServer</mred>只不过根据项目的复杂度，具体的配置会有不同的变化，下面介绍一下具体每个属性的作用和对应的参数的作用。</p>\n<h4 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a><mblack>entry</mblack></h4><p>根据词意，可以知道这是入口，简而言之就是你需要打包的入口js文件，路径和名称就在这里定义的，<mred>webpack</mred>打包的时候会找到这个入口文件，然后根据入口文件写入的依赖解析路径去引入对应的模块。写法也比较灵活，可以写成以下三种形式：</p>\n<ol>\n<li><p>单页面应用入口，String类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: <span class=\"string\">\"./src/app.js\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多页面应用入口，Array类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: [<span class=\"string\">\"./src/app1.js\"</span>,<span class=\"string\">\"./src/app2.js\"</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多页面应用入口，Object类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    chunk1: <span class=\"string\">\"./src/app1.js\"</span>,</span><br><span class=\"line\">    chunk2: <span class=\"string\">\"./src/app2.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果想把不同的<mred>chunk</mred>区别开来，推荐用<strong>Object</strong>的形式，<strong>Object</strong>的<strong>key</strong>值对应了每个<mred>chunk</mred>的名称，使结构更清晰。</p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a><mblack>output</mblack></h4><p>该属性对应了打包的输出配置项，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: <span class=\"string\">'./dist'</span>,</span><br><span class=\"line\">    filename:<span class=\"string\">'js/[name].bundle.js'</span>,<span class=\"comment\">//或者'js/[id].bundle.js'、'js/[name].[hash].bundle.js'、'js/[chunkhash].bundle.js'</span></span><br><span class=\"line\">    chunkFilename:<span class=\"string\">'js/[name].js'</span>,</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><mred>path</mred> 代表了打包后输出的目录路径，为绝对路径。</p>\n<p><mred>filename</mred> 代表了打包输出文件的名称，对应的是从入口进入的<mred>chunk</mred>打包后的文件名，其中<mred>[name]</mred>属性会被<mred>chunk</mred>的名字替换，<mred>[id]</mred>会被模块id（chunk id）所替换，<mred>[hash]</mred>会被每次构建产生的唯一的<mred>hash</mred>值替换，<mred>[chunkhash]</mred>会被根据<mred>chunk</mred>内容生成的<mred>hash</mred>值替换。</p>\n<p><mred>chunkFilename</mred> 是为了那些不是从标准入口进入的<mred>chunk</mred>命名用的，比较常见的就是通过<mred>CommonsChunkPlugin</mred>打包基础模块，比如<mred>react</mred>、<mred>redux</mred>这类的模块，而不是用户自己写的<mred>chunk</mred>模块，命名规则参考<mred>filename</mred>，是一样的。</p>\n<p><mred>publicPath</mred>这个配置项是为一些外部引入的资源如（图片，文件等）设置外部访问的公共<mred>URL</mred>，为什么要这么做呢？原因其实很简单，一句话概括就是开发环境和生产环境的不同，举个栗子：<br>比如你在开发环境写代码的时候你有一张图片是这么引入的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// page/login/index.css</span></span><br><span class=\"line\">background-image:<span class=\"string\">'../../img/login.png'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//你的目录结构</span></span><br><span class=\"line\">├── app.html</span><br><span class=\"line\">├── app.js</span><br><span class=\"line\">├── css</span><br><span class=\"line\">│   └── index.css</span><br><span class=\"line\">├── img</span><br><span class=\"line\">│   └── logo.png</span><br><span class=\"line\">└── page</span><br><span class=\"line\">    └── login</span><br><span class=\"line\">        ├── index.css</span><br><span class=\"line\">        └── login.js</span><br></pre></td></tr></table></figure></p>\n<p>之后不管你是启动本地服务器或者发布到正式环境，都会进行一次打包，不管打包进内存或到某个输出目录，你的目录结构可能就变成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dist</span></span><br><span class=\"line\">├── css</span><br><span class=\"line\">│   └── app.css</span><br><span class=\"line\">├── img</span><br><span class=\"line\">│   └── logo.png</span><br><span class=\"line\">└── index.html</span><br></pre></td></tr></table></figure></p>\n<p>很显然，目录的层级发生了变化，这时候你原先写的相对路径就变得不可靠了，会因找不到资源而报404，<mred>publicPath</mred>就是为了解决这个而提出的，它可以是相对路径也可以是绝对路径，以下摘一段官网的配置说明：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">publicPath: <span class=\"string\">\"https://cdn.example.com/assets/\"</span>, <span class=\"comment\">// CDN（总是 HTTPS 协议）</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"//cdn.example.com/assets/\"</span>, <span class=\"comment\">// CDN (协议相同)</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"/assets/\"</span>, <span class=\"comment\">// 相对于服务(server-relative)</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"assets/\"</span>, <span class=\"comment\">// 相对于 HTML 页面</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"../assets/\"</span>, <span class=\"comment\">// 相对于 HTML 页面</span></span><br><span class=\"line\">publicPath: <span class=\"string\">\"\"</span>, <span class=\"comment\">// 相对于 HTML 页面（目录相同）</span></span><br></pre></td></tr></table></figure></p>\n<p>它当做相对路径写的时候可以相对于自己本身或者服务器的根目录的，所以我们之前如果设置了<mred>publicPath</mred>，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">publicPath: <span class=\"string\">'/img/'</span> <span class=\"comment\">//相对于服务器根目录</span></span><br><span class=\"line\">publicPath: <span class=\"string\">'../img/'</span> <span class=\"comment\">//相对于自己</span></span><br></pre></td></tr></table></figure></p>\n<p>那么最后我们在<mred>app.css</mred>里面看到的路径就会是这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.css</span></span><br><span class=\"line\">background-image:<span class=\"string\">'/img/login.png'</span> <span class=\"comment\">//相对于服务器根目录</span></span><br><span class=\"line\">background-image:<span class=\"string\">'../img/login.png'</span> <span class=\"comment\">//相对于自己</span></span><br></pre></td></tr></table></figure></p>\n<p>怎么样，这样就很清晰了吧。这里还得提一点需要注意的，<mred> output.publicPath</mred>只是默认构建的时候的全局配置，有些<mred>loader</mred>也有自己的<mred>publicPath</mred>，这就看具体情境了，如果<mred>loader</mred>也配置了，那默认就是以<mred>loader</mred>配置的为主。</p>\n<blockquote>\n<p>有些童鞋很惧怕这种属性，觉得和<mred>Path</mred>很像，就默认是差不多用处了，不会再去深究。这样对知识的积累很不好，记住一个原则，配置或属性只是为了给我们提供方便，没必要去惧怕它，都是为了解决某些问题而提出的，当我们明白它的用途，我们才能更好的解读配置的意义。</p>\n</blockquote>\n<h4 id=\"devtool\"><a href=\"#devtool\" class=\"headerlink\" title=\"devtool\"></a><mblack>devtool</mblack></h4><p><mred>devtool</mred>可以让打包后的文件支持<mred>source-map</mred>，以对打包压缩后的代码进行调试，贴一张官网的配置参数图：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtool: <span class=\"string\">\"source-map\"</span>, <span class=\"comment\">// enum</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"inline-source-map\"</span>, <span class=\"comment\">// 嵌入到源文件中</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"eval-source-map\"</span>, <span class=\"comment\">// 将 SourceMap 嵌入到每个模块中</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"hidden-source-map\"</span>, <span class=\"comment\">// SourceMap 不在源文件中引用</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"cheap-source-map\"</span>, <span class=\"comment\">// 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"cheap-module-source-map\"</span>, <span class=\"comment\">// 有模块映射(module mappings)的 SourceMap 低级变体</span></span><br><span class=\"line\">devtool: <span class=\"string\">\"eval\"</span>, <span class=\"comment\">// 没有模块映射，而是命名模块。以牺牲细节达到最快。</span></span><br><span class=\"line\"><span class=\"comment\">// 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试</span></span><br><span class=\"line\"><span class=\"comment\">// 牺牲了构建速度的 `source-map' 是最详细的。</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a><mblack>context</mblack></h4><p>该配置项设置<mred>webpack</mred>的主目录<mred>entry</mred>和 <mred>module.rules.loader</mred>选项相对于此目录解析，也就是以设置的目录为基准解析路径。</p>\n<h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a><mblack>module</mblack></h4><p>这个选项为了处理项目中的不同类型的模块，配置也比较复杂，本文只拿常用的出来讲解，想看详细的配置说明请看<a href=\"https://doc.webpack-china.org/configuration/module\" target=\"_blank\" rel=\"noopener\"><mlink>官网</mlink></a>，之前注释里说的<mred>webpack</mred>不同版本的问题，这里就有体现，对于<mred><a href=\"mailto:webpack@1.x\" target=\"_blank\" rel=\"noopener\">webpack@1.x</a></mred>版本下，<mred>module</mred>的配置可能是下面这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;<span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css'</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(jpg|png|gif|svg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url?limit=8192&#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>而<mred><a href=\"mailto:webpack@2.x\" target=\"_blank\" rel=\"noopener\">webpack@2.x</a></mred>版本下，则写法统一改成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.(jsx|js)$/</span>,</span><br><span class=\"line\">            include: SRC_PATH,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>值得一提的是，不仅写法变了，<mred><a href=\"mailto:webpack@2.x\" target=\"_blank\" rel=\"noopener\">webpack@2.x</a></mred>以后，<mred>-loader</mred>都不能被省略，不然会报语法错误。</p>\n<p><mred>rules</mred>是<mred>module</mred>的核心属性，它会提供一种规则数组，创建模块时，会去匹配并修改模块的创建方式。每个规则可以分为三部分<mred>条件(condition)</mred>，<mred>结果(result)</mred>和<mred>嵌套规则(nested rule)</mred>。</p>\n<p><mred>条件(condition)</mred>很好理解，举个栗子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./css/index.css'</span></span><br></pre></td></tr></table></figure></p>\n<p><mred>条件(condition)</mred>包括了被引入文件<mred>./css/index.css</mred>和导入这个文件的模块<mred>app.js</mred>两个文件的绝对路径。你也可以通过制定<mred>test</mred>的规则去匹配和筛选<mred>条件(condition)</mred>所匹配的文件流。</p>\n<p><mred>结果(result)</mred>里面包含了一些<mred>loader</mred>，当<mred>条件(condition)</mred>满足时，会去匹配对应的被引入的文件流，对这些文件进行处理，生成对应的js模块。简单来说，对引入文件的预处理就在这里面，比如把ES6语法编译成ES5，把JSX编译成ES5，把引入的css，img转换成js模块等等。</p>\n<p><mred>嵌套规则(nested rule)</mred>可以使用属性<mred>rules</mred>和<mred>oneOf</mred>指定嵌套规则。这些规则用于在<mred>规则条件(rule condition)</mred>匹配时进行取值。</p>\n<h4 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve\"></a><mblack>resolve</mblack></h4><p>这个选项能设置模块如何被解析，简单来说就是通过一定的规则去预定义<mred>webpack</mred>查找模块的方式，举个简单的栗子：<br>比如你在<mred>app.js</mred>这样引入一个<mred>login模块</mred><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> login <span class=\"keyword\">from</span> <span class=\"string\">'./router/login'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>如果你设置了<mred>resolve</mred>参数，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.js</span></span><br><span class=\"line\"> alias: &#123;</span><br><span class=\"line\">           <span class=\"string\">'login'</span>:path.resolve(__dirname, <span class=\"string\">'src/router/login'</span>),</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以把之前的相对路径直接替换成：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> login <span class=\"keyword\">from</span> <span class=\"string\">'login'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样写是不是简洁不少？当<mred>webpack</mred>查找<mred>login模块</mred>时，会直接根据你设置的绝对路径去查找，当层级很深的时候，再按相对路径去找明显太蠢了，这样写不仅省时，代码的可读性也更高了，下面简单介绍一下它的其他几个参数（比较常用）。</p>\n<p><mred>extensions</mred>是用来自动解析模块扩展名的，这个懒人必备，哈哈，写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.js</span></span><br><span class=\"line\">extensions: [<span class=\"string\">\".js\"</span>, <span class=\"string\">\".json\"</span>,<span class=\"string\">\".jsx\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>这样你再引入模块的时候就不用写扩展名了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> userList <span class=\"keyword\">from</span> <span class=\"string\">'login/userList.jsx'</span>; <span class=\"comment\">//设置之前</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> userList <span class=\"keyword\">from</span> <span class=\"string\">'login/userList'</span>; <span class=\"comment\">//设置之后</span></span><br></pre></td></tr></table></figure></p>\n<p>设置之后，<mred>webpack</mred>再解析模块的时候会自动补全扩展名。</p>\n<p><mred>modules</mred>告诉<mred>webpack</mred>解析模块时应该搜索的目录。默认是搜索<mred>node_modules</mred>，搜索方式类似<mred>node</mred>通过相对路径一层层往上找。当我们想让<mred>webpack</mred>搜索指定目录，提高搜索效率的时候，也可以这么写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.js</span></span><br><span class=\"line\">modules: [path.resolve(__dirname, <span class=\"string\">\"src\"</span>), <span class=\"string\">\"node_modules\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>这样<mred>webpack</mred>会在搜索<mred>node_modules</mred>之前先搜索你指定的目录，此路径应是绝对路径。</p>\n<h4 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a><mblack>plugins</mblack></h4><p><mred>plugins</mred>为<mred>webpack</mred>的插件列表，这个看具体插件，不同插件的写法不同，但都是实例化了一个对象，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">       <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">           minify: &#123;</span><br><span class=\"line\">               collapseWhitespace: <span class=\"literal\">true</span></span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           chunks: [<span class=\"string\">'app'</span>, <span class=\"string\">'libs'</span>],</span><br><span class=\"line\">           template: SRC_PATH + <span class=\"string\">'/app.ejs'</span></span><br><span class=\"line\">       &#125;),</span><br><span class=\"line\">       <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">           filename: <span class=\"string\">'css/[name].[contenthash].css'</span>,</span><br><span class=\"line\">           disable: __DEV__,</span><br><span class=\"line\">           allChunks: <span class=\"literal\">true</span></span><br><span class=\"line\">       &#125;),</span><br><span class=\"line\">       <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">           name: [<span class=\"string\">\"libs\"</span>,<span class=\"string\">\"manifest\"</span>], </span><br><span class=\"line\">           minChunks: <span class=\"literal\">Infinity</span></span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">   ]</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>善用插件可以帮我们简化开发流程，之后的博客会介绍一下比较常用<mred>webpack</mred>插件及其配置。</p>\n</blockquote>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a><mblack>watch</mblack></h4><p><mred>watch</mred>模式意味着在初始构建之后，<mred>webpack</mred>将继续监听任何已解析文件的更改，这个配置项我们基本不用去设置，因为开了下面这个配置项是默认开启<mred>watch</mred>模式的。</p>\n<h4 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a><mblack>devServer</mblack></h4><p><mred>devServer</mred>是<mred>webpack</mred>的本地服务器，它使我们的开发变的自动而高效，由于它的配置项很多，我们这里也只讲常用的几个。</p>\n<p><mred>contentBase</mred>告诉服务器从哪里提供内容，<mred>webpack</mred>的本地服务器本质上是一个通过node启动的本地资源服务器，这里要了解个概念，通过本地服务器打包是不会生成实体文件的，而是会写进内存里面，既然没实体文件，那我们能提供的静态资源也只能是我们本地的资源文件，这就是<mred>contentBase</mred>的作用，默认是项目根目录：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contentBase: <span class=\"string\">'/'</span></span><br></pre></td></tr></table></figure></p>\n<p>当然你也可以自定义路径，比如我有一个目录结构是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── app.js</span><br><span class=\"line\">│   └── index.html</span><br><span class=\"line\">└── webpack.config.js</span><br></pre></td></tr></table></figure></p>\n<p>当你没设置<mred>contentBase</mred>时<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">\t  compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t  port: <span class=\"number\">9000</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你启动本地服务器后，因为默认是项目根目录，也就是这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//localhost:9000/</span></span><br></pre></td></tr></table></figure></p>\n<p>很显然，根目录下面没有静态资源可以加载的，我们的静态资源都在<mred>src</mred>里面，所以会出现下面的情况<br><img src=\"/2017/08/31/webpack的配置解析/error.png\" alt=\"webpack的配置解析\"><br>当我们进入<mred>src</mred>里面的时候发现资源加载成功了<br><img src=\"/2017/08/31/webpack的配置解析/work.png\" alt=\"webpack的配置解析\"><br>所以我们可以试着把<mred>contentBase</mred>加上<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">     contentBase: __dirname+<span class=\"string\">'/src/'</span>,</span><br><span class=\"line\">\t  compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t  port: <span class=\"number\">9000</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再启动本地服务器，会看到这么一句话<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content is served <span class=\"keyword\">from</span> /Users/fengji/Desktop/demo/src/</span><br></pre></td></tr></table></figure></p>\n<p>代表我们设置成功了，这时候你打开9000端口可以看到这样<br><img src=\"/2017/08/31/webpack的配置解析/success.png\" alt=\"webpack的配置解析\"><br>这样就请求到了我们本地资源，要是你嫌设置麻烦，推荐使用<mred>html-webpack-plugin</mred>它会帮你把资源路径正确定义到你html页面的文件夹下。</p>\n<p><mred>compress</mred>代表是否启用<mred>gzip 压缩</mred>，推荐都设置为<mred>true</mred>，加载压缩完后的资源能加快构建速度。</p>\n<p><mred>port</mred>为你要开启服务器的端口。</p>\n<p><mred>inline</mred>设置为<mred>true</mred>，<mred>webpack</mred>会把一段实时刷新页面的脚本内联进你打包后的<mred>bundle</mred>文件里，你可以在控制台实时看到构建的信息。设置为<mred>flase</mred>，则用<mred>iframe</mred>内嵌html的形式构建，消息会实时显示在页面上，两种方式都可以用，个人比较偏向启用，控制台看起来直观一点。</p>\n<p><mred>hot</mred>模式为不刷新页面的情况下进行模块的热替换，这个才是自动化构建的精髓啊，强烈推荐开启！来体验实时构建的快感吧。</p>\n<blockquote>\n<p>多提一句，要开启<mred>hot</mred>模式，还需要一个插件的支持<mred>webpack.HotModuleReplacementPlugin</mred>，直接用就行了，也很方便。</p>\n</blockquote>\n<p>配置讲解差不多就这么多了，有哪里说的不对的，欢迎在底下评论，大家一起交流进步，后面可能会讲一些插件的用法，或者构建一个完整项目的流程，怎么区分生产和开发环境等等。。</p>\n<h4 id=\"备注：本篇博客皆为博主原创，转发请标明出处。\"><a href=\"#备注：本篇博客皆为博主原创，转发请标明出处。\" class=\"headerlink\" title=\"备注：本篇博客皆为博主原创，转发请标明出处。\"></a>备注：本篇博客皆为博主原创，转发请标明出处。</h4>"},{"title":"工作中遇到的bug整理","date":"2018-04-02T05:52:45.000Z","_content":"\n![bug整理](工作中遇到的bug整理/bug.jpg)\n\n本篇主要为了整理和收集日常开发中遇到的各种bug，防止下次再犯同样的错误，包括了pc端，低版本IE的兼容问题和移动端ios、安卓的兼容问题。\n\n<!-- more -->\n\n## <mblue>PC端bug整理收集</mblue>\n\n### <mblack>1. IE低版本浮动错位问题</mblack>\n\n#### 问题分析\n\nIE6/IE7/IE8<mred>float:right</mred>属性，会导致换行，而不是在同一行显示。\n\n#### 解决办法\n\n将<mred>float:right</mred>属性写在<mred>float:left</mred>或者不浮动的元素之前。\n\n## <mblue>移动端bug整理收集</mblue>\n\n### <mblack>1. fixed键盘兼容问题</mblack>\n\n#### 问题分析\n\nios和部分安卓机型，当键盘弹出的时候，底部<mred>fixed</mred>布局的元素，会被键盘顶到上面来，导致布局错位。\n\n#### 解决办法\n\nios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。\n\n###<mblack>2. fixed导致ios光标移位</mblack>\n\n#### 问题分析\n\n在用<mred>vue</mred>搭建项目的时候，发现当用<mred>input</mred>框进行内容输入的时候，经常会发生光标移位的问题，定位不准，不能很好的在<mred>input</mred>框上获得焦点\n\n#### 解决办法\n\nios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。","source":"_posts/工作中遇到的bug整理.md","raw":"---\ntitle: 工作中遇到的bug整理\ndate: 2018-04-02 13:52:45\ntags: bugs\n---\n\n![bug整理](工作中遇到的bug整理/bug.jpg)\n\n本篇主要为了整理和收集日常开发中遇到的各种bug，防止下次再犯同样的错误，包括了pc端，低版本IE的兼容问题和移动端ios、安卓的兼容问题。\n\n<!-- more -->\n\n## <mblue>PC端bug整理收集</mblue>\n\n### <mblack>1. IE低版本浮动错位问题</mblack>\n\n#### 问题分析\n\nIE6/IE7/IE8<mred>float:right</mred>属性，会导致换行，而不是在同一行显示。\n\n#### 解决办法\n\n将<mred>float:right</mred>属性写在<mred>float:left</mred>或者不浮动的元素之前。\n\n## <mblue>移动端bug整理收集</mblue>\n\n### <mblack>1. fixed键盘兼容问题</mblack>\n\n#### 问题分析\n\nios和部分安卓机型，当键盘弹出的时候，底部<mred>fixed</mred>布局的元素，会被键盘顶到上面来，导致布局错位。\n\n#### 解决办法\n\nios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。\n\n###<mblack>2. fixed导致ios光标移位</mblack>\n\n#### 问题分析\n\n在用<mred>vue</mred>搭建项目的时候，发现当用<mred>input</mred>框进行内容输入的时候，经常会发生光标移位的问题，定位不准，不能很好的在<mred>input</mred>框上获得焦点\n\n#### 解决办法\n\nios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。","slug":"工作中遇到的bug整理","published":1,"updated":"2020-01-07T02:31:54.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck53b1upa00030vk5dy2m76fl","content":"<p><img src=\"/2018/04/02/工作中遇到的bug整理/bug.jpg\" alt=\"bug整理\"></p>\n<p>本篇主要为了整理和收集日常开发中遇到的各种bug，防止下次再犯同样的错误，包括了pc端，低版本IE的兼容问题和移动端ios、安卓的兼容问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"PC端bug整理收集\"><a href=\"#PC端bug整理收集\" class=\"headerlink\" title=\"PC端bug整理收集\"></a><mblue>PC端bug整理收集</mblue></h2><h3 id=\"1-IE低版本浮动错位问题\"><a href=\"#1-IE低版本浮动错位问题\" class=\"headerlink\" title=\"1. IE低版本浮动错位问题\"></a><mblack>1. IE低版本浮动错位问题</mblack></h3><h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>IE6/IE7/IE8<mred>float:right</mred>属性，会导致换行，而不是在同一行显示。</p>\n<h4 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>将<mred>float:right</mred>属性写在<mred>float:left</mred>或者不浮动的元素之前。</p>\n<h2 id=\"移动端bug整理收集\"><a href=\"#移动端bug整理收集\" class=\"headerlink\" title=\"移动端bug整理收集\"></a><mblue>移动端bug整理收集</mblue></h2><h3 id=\"1-fixed键盘兼容问题\"><a href=\"#1-fixed键盘兼容问题\" class=\"headerlink\" title=\"1. fixed键盘兼容问题\"></a><mblack>1. fixed键盘兼容问题</mblack></h3><h4 id=\"问题分析-1\"><a href=\"#问题分析-1\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>ios和部分安卓机型，当键盘弹出的时候，底部<mred>fixed</mred>布局的元素，会被键盘顶到上面来，导致布局错位。</p>\n<h4 id=\"解决办法-1\"><a href=\"#解决办法-1\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>ios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。</p>\n<p>###<mblack>2. fixed导致ios光标移位</mblack></p>\n<h4 id=\"问题分析-2\"><a href=\"#问题分析-2\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>在用<mred>vue</mred>搭建项目的时候，发现当用<mred>input</mred>框进行内容输入的时候，经常会发生光标移位的问题，定位不准，不能很好的在<mred>input</mred>框上获得焦点</p>\n<h4 id=\"解决办法-2\"><a href=\"#解决办法-2\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>ios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2018/04/02/工作中遇到的bug整理/bug.jpg\" alt=\"bug整理\"></p>\n<p>本篇主要为了整理和收集日常开发中遇到的各种bug，防止下次再犯同样的错误，包括了pc端，低版本IE的兼容问题和移动端ios、安卓的兼容问题。</p>","more":"<h2 id=\"PC端bug整理收集\"><a href=\"#PC端bug整理收集\" class=\"headerlink\" title=\"PC端bug整理收集\"></a><mblue>PC端bug整理收集</mblue></h2><h3 id=\"1-IE低版本浮动错位问题\"><a href=\"#1-IE低版本浮动错位问题\" class=\"headerlink\" title=\"1. IE低版本浮动错位问题\"></a><mblack>1. IE低版本浮动错位问题</mblack></h3><h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>IE6/IE7/IE8<mred>float:right</mred>属性，会导致换行，而不是在同一行显示。</p>\n<h4 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>将<mred>float:right</mred>属性写在<mred>float:left</mred>或者不浮动的元素之前。</p>\n<h2 id=\"移动端bug整理收集\"><a href=\"#移动端bug整理收集\" class=\"headerlink\" title=\"移动端bug整理收集\"></a><mblue>移动端bug整理收集</mblue></h2><h3 id=\"1-fixed键盘兼容问题\"><a href=\"#1-fixed键盘兼容问题\" class=\"headerlink\" title=\"1. fixed键盘兼容问题\"></a><mblack>1. fixed键盘兼容问题</mblack></h3><h4 id=\"问题分析-1\"><a href=\"#问题分析-1\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>ios和部分安卓机型，当键盘弹出的时候，底部<mred>fixed</mred>布局的元素，会被键盘顶到上面来，导致布局错位。</p>\n<h4 id=\"解决办法-1\"><a href=\"#解决办法-1\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>ios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。</p>\n<p>###<mblack>2. fixed导致ios光标移位</mblack></p>\n<h4 id=\"问题分析-2\"><a href=\"#问题分析-2\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>在用<mred>vue</mred>搭建项目的时候，发现当用<mred>input</mred>框进行内容输入的时候，经常会发生光标移位的问题，定位不准，不能很好的在<mred>input</mred>框上获得焦点</p>\n<h4 id=\"解决办法-2\"><a href=\"#解决办法-2\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>ios通过更改为<mred>flex</mred>布局，可以解决，而部分安卓机型还是有问题，最终解决办法是通过js获取当前手机视窗的高度，给最外面的容器加一个<mred>min-height</mred>，good！完美解决bug。</p>"},{"title":"浅谈浏览器加载优化","date":"2017-07-18T16:12:40.000Z","_content":"呼~总算搞定了博客，终于可以写一点自己的东西了，第一篇博客就来聊聊关于**浏览器加载速度**的话题，这个直接关乎用户在浏览我们网站时候的体验，也是作为我们前端工程师所必须了解的。\n\n<!-- more -->\n\n## <mblue>浏览器加载网页的过程</mblue>\n既然要探讨加载问题，我们首先得先知道浏览器是怎么加载网页的，知道了加载过程，就能针对其中的一些点进行不同程度的优化，浏览器加载网页的过程大致分为以下几步：\n\n  ![浏览器加载过程](浅谈浏览器加载优化/render_dom.png)\n  \n   1. 浏览器接受到服务器的html响应，开始以**8k / chunk**的速度开始下载html页面\n   2. 浏览器开始解析页面代码，并开始构建<mred>DOM树</mred>\n   3. 遇到css标签或者js标签就重新开启线程去下载对应的文件，然后继续构建<mred>DOM树</mred>\n   4. 当css文件下载完后，开始解析css为<mred>CSS规则树</mred>，然后浏览器根据<mred>CSS规则树</mred>和<mred>DOM树</mred>生成<mred>render tree</mred>，也就是开始渲染页面了\n   5. 当js文件下载完后，开始解析js文件，若js文件里有修改dom的**DOM API** 或者修改css样式的**CSSOM API**，每次执行都会使<mred>render tree</mred>重新渲染，相比而言，修改dom的代价更高，它会使<mred>render tree</mred>重新布局构建（reflow）然后进行重新渲染（repaint），而修改样式只会触发重新渲染。\n   6. 渲染完成，显示页面\n\n## <mblue>简单优化的一些建议</mblue>\n### <mblack>压缩css和javascript文件</mblack>\n既然是从服务器上下载下来的，首先想到的自然就是减少下载下来的文件体积。压缩就是一个很好的办法，市面上有很多工具可以帮助我们完成压缩的工作，个人比较推荐用<mred>Uglify</mred>，这是一个用来完成压缩操作的包，可以配合一些任务流工具如<mred>grunt</mred>，<mred>gulp</mred>来快速压缩我们生产环境所需要的js和css文件，因为这是npm的包，所以你必须先装有<mred>node</mred>和<mred>npm</mred>。安装去官网找一下就可以了。\n\n安装<mred>Uglify</mred>的指令为：\n\n``` bash\nnpm install uglify-js -g\n\n```\n\n使用也很简单，博主在这就不展开了，具体文档点[<mlink>这里</mlink>](https://github.com/mishoo/UglifyJS2)。\n\n### <mblack>启用GZIP压缩</mblack>\n压缩完css和javascript文件，我们是不是也能把html页面也压缩一下呢，毕竟页面是最先下载的，要是能压缩体积，必定能提升网站的访问速度。我们可以在服务器上通过**Gzip**压缩做到这一点，这能有效减少HTTP响应的时间，提高访问速度。\n\n### <mblack>使用 CSS Sprites</mblack>\n俗称css精灵或雪碧图，把多个小图片整合到一张大图片中，需要取某张图片的话，通过<mred>background-position</mred>来定位需要的图片，这样资源只需要请求一次，不需要多次请求，常见的应用就是各种图标的整合，有效提高了打开网站的速度。\n\n### <mblack>CSS文件放在页面顶部，而JS文件放在底部</mblack>\n根据我们之前了解的网站加载过程，可以知道css是用来渲染整颗<mred>DOM树</mred>的，那么如果放在页面最后面的话，等<mred>DOM树</mred>构建完成，再开始生成<mred>render tree</mred>，然后浏览器不得不重新渲染整颗树，这样显然效率不高，网速慢的话容易出现短暂的视觉空白，影响用户体验。\n\n而对于js文件来说，它会阻塞DOM树的构建，若放在<mred>head</mred>标签中，显然不合理，无法让用户第一时间看到页面，所以放在<mred>body</mred>标签的最后是比较合理的。\n\n### <mblack>利用浏览器的缓存</mblack>\n浏览器自带缓存功能，能避免重复文件的多次下载，但是这个有时候也是个缺点，若有一些新的文件的版本更新，浏览器里可能还留着老版本文件的缓存导致不能更新到最新版本，这点对于一些更新频繁的网站是致命的，解决办法是给文件后面加<mred>v=</mred>版本号，使有文件更新的时候去服务器端重新下载最新的文件。\n\n### <mblack>使用内容分发网络(CDN)</mblack>\n当一个网站的流量很大的时候，会对服务器造成很大的压力，处理的东西多了自然用户打开页面的时候就慢了，<mred>CDN</mred>主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，不同地区的用户的用户可以就近访问对应的节点，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。\n\n### <mblack>减少重定向</mblack>\n重定向增加了额外的HTTP请求，也增加了页面加载时间。\n#### 备注：本篇博客皆为博主原创，转发请标明出处。\n\n\n\n\n\n   \n ","source":"_posts/浅谈浏览器加载优化.md","raw":"---\ntitle: 浅谈浏览器加载优化\ndate: 2017-07-19 00:12:40\ntags: 浏览器加载优化\n---\n呼~总算搞定了博客，终于可以写一点自己的东西了，第一篇博客就来聊聊关于**浏览器加载速度**的话题，这个直接关乎用户在浏览我们网站时候的体验，也是作为我们前端工程师所必须了解的。\n\n<!-- more -->\n\n## <mblue>浏览器加载网页的过程</mblue>\n既然要探讨加载问题，我们首先得先知道浏览器是怎么加载网页的，知道了加载过程，就能针对其中的一些点进行不同程度的优化，浏览器加载网页的过程大致分为以下几步：\n\n  ![浏览器加载过程](浅谈浏览器加载优化/render_dom.png)\n  \n   1. 浏览器接受到服务器的html响应，开始以**8k / chunk**的速度开始下载html页面\n   2. 浏览器开始解析页面代码，并开始构建<mred>DOM树</mred>\n   3. 遇到css标签或者js标签就重新开启线程去下载对应的文件，然后继续构建<mred>DOM树</mred>\n   4. 当css文件下载完后，开始解析css为<mred>CSS规则树</mred>，然后浏览器根据<mred>CSS规则树</mred>和<mred>DOM树</mred>生成<mred>render tree</mred>，也就是开始渲染页面了\n   5. 当js文件下载完后，开始解析js文件，若js文件里有修改dom的**DOM API** 或者修改css样式的**CSSOM API**，每次执行都会使<mred>render tree</mred>重新渲染，相比而言，修改dom的代价更高，它会使<mred>render tree</mred>重新布局构建（reflow）然后进行重新渲染（repaint），而修改样式只会触发重新渲染。\n   6. 渲染完成，显示页面\n\n## <mblue>简单优化的一些建议</mblue>\n### <mblack>压缩css和javascript文件</mblack>\n既然是从服务器上下载下来的，首先想到的自然就是减少下载下来的文件体积。压缩就是一个很好的办法，市面上有很多工具可以帮助我们完成压缩的工作，个人比较推荐用<mred>Uglify</mred>，这是一个用来完成压缩操作的包，可以配合一些任务流工具如<mred>grunt</mred>，<mred>gulp</mred>来快速压缩我们生产环境所需要的js和css文件，因为这是npm的包，所以你必须先装有<mred>node</mred>和<mred>npm</mred>。安装去官网找一下就可以了。\n\n安装<mred>Uglify</mred>的指令为：\n\n``` bash\nnpm install uglify-js -g\n\n```\n\n使用也很简单，博主在这就不展开了，具体文档点[<mlink>这里</mlink>](https://github.com/mishoo/UglifyJS2)。\n\n### <mblack>启用GZIP压缩</mblack>\n压缩完css和javascript文件，我们是不是也能把html页面也压缩一下呢，毕竟页面是最先下载的，要是能压缩体积，必定能提升网站的访问速度。我们可以在服务器上通过**Gzip**压缩做到这一点，这能有效减少HTTP响应的时间，提高访问速度。\n\n### <mblack>使用 CSS Sprites</mblack>\n俗称css精灵或雪碧图，把多个小图片整合到一张大图片中，需要取某张图片的话，通过<mred>background-position</mred>来定位需要的图片，这样资源只需要请求一次，不需要多次请求，常见的应用就是各种图标的整合，有效提高了打开网站的速度。\n\n### <mblack>CSS文件放在页面顶部，而JS文件放在底部</mblack>\n根据我们之前了解的网站加载过程，可以知道css是用来渲染整颗<mred>DOM树</mred>的，那么如果放在页面最后面的话，等<mred>DOM树</mred>构建完成，再开始生成<mred>render tree</mred>，然后浏览器不得不重新渲染整颗树，这样显然效率不高，网速慢的话容易出现短暂的视觉空白，影响用户体验。\n\n而对于js文件来说，它会阻塞DOM树的构建，若放在<mred>head</mred>标签中，显然不合理，无法让用户第一时间看到页面，所以放在<mred>body</mred>标签的最后是比较合理的。\n\n### <mblack>利用浏览器的缓存</mblack>\n浏览器自带缓存功能，能避免重复文件的多次下载，但是这个有时候也是个缺点，若有一些新的文件的版本更新，浏览器里可能还留着老版本文件的缓存导致不能更新到最新版本，这点对于一些更新频繁的网站是致命的，解决办法是给文件后面加<mred>v=</mred>版本号，使有文件更新的时候去服务器端重新下载最新的文件。\n\n### <mblack>使用内容分发网络(CDN)</mblack>\n当一个网站的流量很大的时候，会对服务器造成很大的压力，处理的东西多了自然用户打开页面的时候就慢了，<mred>CDN</mred>主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，不同地区的用户的用户可以就近访问对应的节点，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。\n\n### <mblack>减少重定向</mblack>\n重定向增加了额外的HTTP请求，也增加了页面加载时间。\n#### 备注：本篇博客皆为博主原创，转发请标明出处。\n\n\n\n\n\n   \n ","slug":"浅谈浏览器加载优化","published":1,"updated":"2020-01-07T02:31:54.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck53b1upb00040vk5wir0dr7b","content":"<p>呼~总算搞定了博客，终于可以写一点自己的东西了，第一篇博客就来聊聊关于<strong>浏览器加载速度</strong>的话题，这个直接关乎用户在浏览我们网站时候的体验，也是作为我们前端工程师所必须了解的。</p>\n<a id=\"more\"></a>\n<h2 id=\"浏览器加载网页的过程\"><a href=\"#浏览器加载网页的过程\" class=\"headerlink\" title=\"浏览器加载网页的过程\"></a><mblue>浏览器加载网页的过程</mblue></h2><p>既然要探讨加载问题，我们首先得先知道浏览器是怎么加载网页的，知道了加载过程，就能针对其中的一些点进行不同程度的优化，浏览器加载网页的过程大致分为以下几步：</p>\n<p>  <img src=\"/2017/07/19/浅谈浏览器加载优化/render_dom.png\" alt=\"浏览器加载过程\"></p>\n<ol>\n<li>浏览器接受到服务器的html响应，开始以<strong>8k / chunk</strong>的速度开始下载html页面</li>\n<li>浏览器开始解析页面代码，并开始构建<mred>DOM树</mred></li>\n<li>遇到css标签或者js标签就重新开启线程去下载对应的文件，然后继续构建<mred>DOM树</mred></li>\n<li>当css文件下载完后，开始解析css为<mred>CSS规则树</mred>，然后浏览器根据<mred>CSS规则树</mred>和<mred>DOM树</mred>生成<mred>render tree</mred>，也就是开始渲染页面了</li>\n<li>当js文件下载完后，开始解析js文件，若js文件里有修改dom的<strong>DOM API</strong> 或者修改css样式的<strong>CSSOM API</strong>，每次执行都会使<mred>render tree</mred>重新渲染，相比而言，修改dom的代价更高，它会使<mred>render tree</mred>重新布局构建（reflow）然后进行重新渲染（repaint），而修改样式只会触发重新渲染。</li>\n<li>渲染完成，显示页面</li>\n</ol>\n<h2 id=\"简单优化的一些建议\"><a href=\"#简单优化的一些建议\" class=\"headerlink\" title=\"简单优化的一些建议\"></a><mblue>简单优化的一些建议</mblue></h2><h3 id=\"压缩css和javascript文件\"><a href=\"#压缩css和javascript文件\" class=\"headerlink\" title=\"压缩css和javascript文件\"></a><mblack>压缩css和javascript文件</mblack></h3><p>既然是从服务器上下载下来的，首先想到的自然就是减少下载下来的文件体积。压缩就是一个很好的办法，市面上有很多工具可以帮助我们完成压缩的工作，个人比较推荐用<mred>Uglify</mred>，这是一个用来完成压缩操作的包，可以配合一些任务流工具如<mred>grunt</mred>，<mred>gulp</mred>来快速压缩我们生产环境所需要的js和css文件，因为这是npm的包，所以你必须先装有<mred>node</mred>和<mred>npm</mred>。安装去官网找一下就可以了。</p>\n<p>安装<mred>Uglify</mred>的指令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install uglify-js -g</span><br></pre></td></tr></table></figure>\n<p>使用也很简单，博主在这就不展开了，具体文档点<a href=\"https://github.com/mishoo/UglifyJS2\" target=\"_blank\" rel=\"noopener\"><mlink>这里</mlink></a>。</p>\n<h3 id=\"启用GZIP压缩\"><a href=\"#启用GZIP压缩\" class=\"headerlink\" title=\"启用GZIP压缩\"></a><mblack>启用GZIP压缩</mblack></h3><p>压缩完css和javascript文件，我们是不是也能把html页面也压缩一下呢，毕竟页面是最先下载的，要是能压缩体积，必定能提升网站的访问速度。我们可以在服务器上通过<strong>Gzip</strong>压缩做到这一点，这能有效减少HTTP响应的时间，提高访问速度。</p>\n<h3 id=\"使用-CSS-Sprites\"><a href=\"#使用-CSS-Sprites\" class=\"headerlink\" title=\"使用 CSS Sprites\"></a><mblack>使用 CSS Sprites</mblack></h3><p>俗称css精灵或雪碧图，把多个小图片整合到一张大图片中，需要取某张图片的话，通过<mred>background-position</mred>来定位需要的图片，这样资源只需要请求一次，不需要多次请求，常见的应用就是各种图标的整合，有效提高了打开网站的速度。</p>\n<h3 id=\"CSS文件放在页面顶部，而JS文件放在底部\"><a href=\"#CSS文件放在页面顶部，而JS文件放在底部\" class=\"headerlink\" title=\"CSS文件放在页面顶部，而JS文件放在底部\"></a><mblack>CSS文件放在页面顶部，而JS文件放在底部</mblack></h3><p>根据我们之前了解的网站加载过程，可以知道css是用来渲染整颗<mred>DOM树</mred>的，那么如果放在页面最后面的话，等<mred>DOM树</mred>构建完成，再开始生成<mred>render tree</mred>，然后浏览器不得不重新渲染整颗树，这样显然效率不高，网速慢的话容易出现短暂的视觉空白，影响用户体验。</p>\n<p>而对于js文件来说，它会阻塞DOM树的构建，若放在<mred>head</mred>标签中，显然不合理，无法让用户第一时间看到页面，所以放在<mred>body</mred>标签的最后是比较合理的。</p>\n<h3 id=\"利用浏览器的缓存\"><a href=\"#利用浏览器的缓存\" class=\"headerlink\" title=\"利用浏览器的缓存\"></a><mblack>利用浏览器的缓存</mblack></h3><p>浏览器自带缓存功能，能避免重复文件的多次下载，但是这个有时候也是个缺点，若有一些新的文件的版本更新，浏览器里可能还留着老版本文件的缓存导致不能更新到最新版本，这点对于一些更新频繁的网站是致命的，解决办法是给文件后面加<mred>v=</mred>版本号，使有文件更新的时候去服务器端重新下载最新的文件。</p>\n<h3 id=\"使用内容分发网络-CDN\"><a href=\"#使用内容分发网络-CDN\" class=\"headerlink\" title=\"使用内容分发网络(CDN)\"></a><mblack>使用内容分发网络(CDN)</mblack></h3><p>当一个网站的流量很大的时候，会对服务器造成很大的压力，处理的东西多了自然用户打开页面的时候就慢了，<mred>CDN</mred>主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，不同地区的用户的用户可以就近访问对应的节点，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。</p>\n<h3 id=\"减少重定向\"><a href=\"#减少重定向\" class=\"headerlink\" title=\"减少重定向\"></a><mblack>减少重定向</mblack></h3><p>重定向增加了额外的HTTP请求，也增加了页面加载时间。</p>\n<h4 id=\"备注：本篇博客皆为博主原创，转发请标明出处。\"><a href=\"#备注：本篇博客皆为博主原创，转发请标明出处。\" class=\"headerlink\" title=\"备注：本篇博客皆为博主原创，转发请标明出处。\"></a>备注：本篇博客皆为博主原创，转发请标明出处。</h4>","site":{"data":{}},"excerpt":"<p>呼~总算搞定了博客，终于可以写一点自己的东西了，第一篇博客就来聊聊关于<strong>浏览器加载速度</strong>的话题，这个直接关乎用户在浏览我们网站时候的体验，也是作为我们前端工程师所必须了解的。</p>","more":"<h2 id=\"浏览器加载网页的过程\"><a href=\"#浏览器加载网页的过程\" class=\"headerlink\" title=\"浏览器加载网页的过程\"></a><mblue>浏览器加载网页的过程</mblue></h2><p>既然要探讨加载问题，我们首先得先知道浏览器是怎么加载网页的，知道了加载过程，就能针对其中的一些点进行不同程度的优化，浏览器加载网页的过程大致分为以下几步：</p>\n<p>  <img src=\"/2017/07/19/浅谈浏览器加载优化/render_dom.png\" alt=\"浏览器加载过程\"></p>\n<ol>\n<li>浏览器接受到服务器的html响应，开始以<strong>8k / chunk</strong>的速度开始下载html页面</li>\n<li>浏览器开始解析页面代码，并开始构建<mred>DOM树</mred></li>\n<li>遇到css标签或者js标签就重新开启线程去下载对应的文件，然后继续构建<mred>DOM树</mred></li>\n<li>当css文件下载完后，开始解析css为<mred>CSS规则树</mred>，然后浏览器根据<mred>CSS规则树</mred>和<mred>DOM树</mred>生成<mred>render tree</mred>，也就是开始渲染页面了</li>\n<li>当js文件下载完后，开始解析js文件，若js文件里有修改dom的<strong>DOM API</strong> 或者修改css样式的<strong>CSSOM API</strong>，每次执行都会使<mred>render tree</mred>重新渲染，相比而言，修改dom的代价更高，它会使<mred>render tree</mred>重新布局构建（reflow）然后进行重新渲染（repaint），而修改样式只会触发重新渲染。</li>\n<li>渲染完成，显示页面</li>\n</ol>\n<h2 id=\"简单优化的一些建议\"><a href=\"#简单优化的一些建议\" class=\"headerlink\" title=\"简单优化的一些建议\"></a><mblue>简单优化的一些建议</mblue></h2><h3 id=\"压缩css和javascript文件\"><a href=\"#压缩css和javascript文件\" class=\"headerlink\" title=\"压缩css和javascript文件\"></a><mblack>压缩css和javascript文件</mblack></h3><p>既然是从服务器上下载下来的，首先想到的自然就是减少下载下来的文件体积。压缩就是一个很好的办法，市面上有很多工具可以帮助我们完成压缩的工作，个人比较推荐用<mred>Uglify</mred>，这是一个用来完成压缩操作的包，可以配合一些任务流工具如<mred>grunt</mred>，<mred>gulp</mred>来快速压缩我们生产环境所需要的js和css文件，因为这是npm的包，所以你必须先装有<mred>node</mred>和<mred>npm</mred>。安装去官网找一下就可以了。</p>\n<p>安装<mred>Uglify</mred>的指令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install uglify-js -g</span><br></pre></td></tr></table></figure>\n<p>使用也很简单，博主在这就不展开了，具体文档点<a href=\"https://github.com/mishoo/UglifyJS2\" target=\"_blank\" rel=\"noopener\"><mlink>这里</mlink></a>。</p>\n<h3 id=\"启用GZIP压缩\"><a href=\"#启用GZIP压缩\" class=\"headerlink\" title=\"启用GZIP压缩\"></a><mblack>启用GZIP压缩</mblack></h3><p>压缩完css和javascript文件，我们是不是也能把html页面也压缩一下呢，毕竟页面是最先下载的，要是能压缩体积，必定能提升网站的访问速度。我们可以在服务器上通过<strong>Gzip</strong>压缩做到这一点，这能有效减少HTTP响应的时间，提高访问速度。</p>\n<h3 id=\"使用-CSS-Sprites\"><a href=\"#使用-CSS-Sprites\" class=\"headerlink\" title=\"使用 CSS Sprites\"></a><mblack>使用 CSS Sprites</mblack></h3><p>俗称css精灵或雪碧图，把多个小图片整合到一张大图片中，需要取某张图片的话，通过<mred>background-position</mred>来定位需要的图片，这样资源只需要请求一次，不需要多次请求，常见的应用就是各种图标的整合，有效提高了打开网站的速度。</p>\n<h3 id=\"CSS文件放在页面顶部，而JS文件放在底部\"><a href=\"#CSS文件放在页面顶部，而JS文件放在底部\" class=\"headerlink\" title=\"CSS文件放在页面顶部，而JS文件放在底部\"></a><mblack>CSS文件放在页面顶部，而JS文件放在底部</mblack></h3><p>根据我们之前了解的网站加载过程，可以知道css是用来渲染整颗<mred>DOM树</mred>的，那么如果放在页面最后面的话，等<mred>DOM树</mred>构建完成，再开始生成<mred>render tree</mred>，然后浏览器不得不重新渲染整颗树，这样显然效率不高，网速慢的话容易出现短暂的视觉空白，影响用户体验。</p>\n<p>而对于js文件来说，它会阻塞DOM树的构建，若放在<mred>head</mred>标签中，显然不合理，无法让用户第一时间看到页面，所以放在<mred>body</mred>标签的最后是比较合理的。</p>\n<h3 id=\"利用浏览器的缓存\"><a href=\"#利用浏览器的缓存\" class=\"headerlink\" title=\"利用浏览器的缓存\"></a><mblack>利用浏览器的缓存</mblack></h3><p>浏览器自带缓存功能，能避免重复文件的多次下载，但是这个有时候也是个缺点，若有一些新的文件的版本更新，浏览器里可能还留着老版本文件的缓存导致不能更新到最新版本，这点对于一些更新频繁的网站是致命的，解决办法是给文件后面加<mred>v=</mred>版本号，使有文件更新的时候去服务器端重新下载最新的文件。</p>\n<h3 id=\"使用内容分发网络-CDN\"><a href=\"#使用内容分发网络-CDN\" class=\"headerlink\" title=\"使用内容分发网络(CDN)\"></a><mblack>使用内容分发网络(CDN)</mblack></h3><p>当一个网站的流量很大的时候，会对服务器造成很大的压力，处理的东西多了自然用户打开页面的时候就慢了，<mred>CDN</mred>主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，不同地区的用户的用户可以就近访问对应的节点，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。</p>\n<h3 id=\"减少重定向\"><a href=\"#减少重定向\" class=\"headerlink\" title=\"减少重定向\"></a><mblack>减少重定向</mblack></h3><p>重定向增加了额外的HTTP请求，也增加了页面加载时间。</p>\n<h4 id=\"备注：本篇博客皆为博主原创，转发请标明出处。\"><a href=\"#备注：本篇博客皆为博主原创，转发请标明出处。\" class=\"headerlink\" title=\"备注：本篇博客皆为博主原创，转发请标明出处。\"></a>备注：本篇博客皆为博主原创，转发请标明出处。</h4>"},{"title":"谈谈js的原型与继承","date":"2017-08-26T06:12:37.000Z","_content":"![谈谈js的原型与继承](谈谈js的原型与继承/pic.jpg)\njavascript是一门弱类型的语言，所以并没有像java这种有类的概念，自然也没有子类继承父类这一说，但是所幸js有自己的一套继承机制，下面我就来谈谈关于js的继承我的一点微薄的理解。\n\n<!-- more -->\n\n## <mblue>构造函数</mblue>\njs创建对象的方式有很多，比如对象字面量直接创建啊，类似这样：\n```javascript\n//这种算是最简单的创建对象的方法，简单粗暴\nvar obj = new Object();//或者\nvar obj = {};\n```\n或者工厂模式创建，类似这样：\n```javascript\n//当你需要批量创建对象时可以用工厂模式统一创建\nfunction factory(name, age) {\n    var obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    obj.dosth = function () {\n        console.log('做些事!');\n    }\n    return obj;\n}\nvar example1 = factory('redjue', 24) // {name: \"redjue\", age: 24, dosth: ƒ}\n```\n亦或者构造函数模式创建，类似这样：\n```javascript\n//构造函数解决了工厂模式反复创建函数方法的弊端，减少了对象的体积\nfunction constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    constructor.prototype.dosth = function () {\n        console.log('做些事!');\n    }\n}\nvar example2 = new constructor('redjue', 24);//{name: \"redjue\", age: 24}\nexample2.dosth() //做些事! \n```\njs的新手看到构造函数这可能会比较迷。。对象里没有<mred>dosth</mred>这个方法，它怎么还能调用到？是被什么‘吃’了吗，事实上它确实被‘吃’了，它被<mred>constructor</mred>的原型对象给接管了，具体形式如下：\n```javascript\n//constructor.prototype\n{\n    dosth:function(){\n        console.log('做些事!'); \n    },\n    constructor:constructor(name, age){...},\n    __proto__:Object    \n}\n```\n那么为什么<mred>example2</mred>能调用到<mred>constructor</mred>原型对象里的方法呢，构造函数的原型对象与他实例化的对象之间是通过什么连接起来的呢？这就要提到另一个概念，原型链的传递。\n\n## <mblue>原型链的传递</mblue>\n### <mblack>构造函数创建实例的过程</mblack>\n构造函数通过<mred>new</mred>关键字来创建实例对象，具体过程如下：\n\n1. 创建一个空对象。\n2. 将构造函数的作用域赋值给这个空对象，也就是改变<mred>this</mred>指向。\n3. 根据构造函数中创建对象的代码，实例化这个空对象。\n4. 返回这个新对象。\n\n我们一步步来看，创建一个空对象就是直接通过对象字面量直接创建一个对象：\n```javascript\nvar newObj = new Object();\n```\n第二步中所做的，可以用以下代码表示：\n\n```javascript\n//让constructor构造函数在newObj的环境下执行，this自然指向newObj\nconstructor.call(newObj);\n//也可以形象的表示成这样\nnewObj = {\n    constructor: function (name, age) {\n        this.name = name;\n        this.age = age;\n        this.constructor.prototype.dosth = function () {\n            console.log('做些事!');\n        }\n    }\n}\n```\n第三步，如下：\n```javascript\n//当然constructor并没有在newObj里面，这段代码只是表示了和call函数做的一样的事\nnewObj.constructor('redjue', 24);\n```\n第四步，返回构造函数的实例：\n```javascript\nreturn newObj \n```\n至此，我们通过构造函数创建了一个实例对象，但是这个过程看起来似乎并没有关于原型链传递的操作对不对？其实嘛，js的底层都帮我们解决了，这里要介绍一个有关原型链传递的关键属性`__proto__`。\n\n### <mblack>proto属性</mblack>\n这个属性为什么能关乎原型链的传递呢？原因就在实例化对象的过程中，<mred>constructor</mred>把自己的原型对象当做一个属性值赋值给了<mred>newObj</mred>，\n而这个被赋值的属性就是`__proto__`，这是一个特殊的属性，专门用来保存指向对应原型的指针。所以当在调用实例对象自己本身没有的属性或方法时，通过这个属性的指向，我们可以去<mred>constructor</mred>的原型里面查找，这一过程称为原型链的传递。特别要注意的一点，这一过程只发生在实例对象与原型之间，而和<mred>constructor</mred>没什么关系。\n\n## <mblue>ES5继承的实现</mblue>\n为什么要说ES5继承呢，主要是ES6出了一个新特性class，通过更优雅的语法来实现继承，但本质上来说和ES5的继承方式是一样的，只不过是一个语法糖，后面再谈ES6继承的一些特性和实现原理。\n### <mblack>常规的实现方式</mblack>\n我们知道了原型链的传递是发生在实例对象和原型之间的，那么我们如果想要实现继承的话，就可以把它们连接起来，类似这样：\n```javascript\nfunction parent(){\n //父类\n this.name='parent';\n this.age=56;\n parent.prototype.dosth = function () {\n    console.log('做些事!');\n}   \n}\nfunction child(){\n //子类\n this.name='child';\n this.age=24;\n}\n\n//连接原型链\nchild.prototype=new parent();\nvar child=new child();\nchild.dosth() //'做些事!'\n```\n子类的实例对象可以通过搜索原型链往上找，最终找到父类原型里面的<mred>dosth</mred>方法。但是这样做有个问题，我们来看看子类的原型：\n```javascript\n//子类原型\n{\n    age: 56,\n    name: \"parent\",\n    __proto__: Object\n}\n```\n发现问题了吗，子类的原型就是父类的实例对象，意味着这个实例对象里面的属性其实是作为原型里的属性而存在的，这违背了属性私有化的理念，我们只是想把方法进行复用，而属性并不需要共有。\n### <mblack>借用构造实现组合继承</mblack>\n既然我们遇到了这个问题，那么有没有什么办法能解决这个问题？有大神用了一种巧妙的办法规避了这个问题，这就是借用构造函数：\n```javascript\nfunction parent() {\n    //父类\n    this.name = 'parent';\n    this.age = 56;\n    parent.prototype.dosth = function () {\n        console.log('做些事!');\n    }\n}\nfunction child() {\n    //子类\n    this.name = 'child';\n    this.age = 24;\n    //将父类的属性在子类中私有化\n    parent.call(this);\n}\n\n//连接原型链\nchild.prototype = new parent();\n//将child原型的constructor指向child自身，默认状态指向的是parent，显然有问题\nchild.prototype.constructor=child;\nvar _child = new child();\n_child.dosth() //'做些事!'\n```\n这样我们保证了，<mred>child</mred>的每个实例对象都有<mred>parent</mred>定义的私有属性，而不是共享<mred>_child</mred>继承的<mred>parent</mred>的实例里面的共有属性，实现了属性私有，方法复用的比较完美的组合继承。\n\n## <mblue>ES6继承的实现</mblue>\n### <mblack>class，static，extend和super关键字</mblack>\nES6引入了一个新的概念<mred>class</mred>，也就是类，形式类似这样：\n```javascript\nclass parent {\n    constructor() {\n        this.name = 'redjue';\n        this.age = 24\n    }\n    dosth() {\n        console.log('做些事!')\n    }\n}\nvar _parent = new parent;//{name: \"redjue\", age: 24}\n```\n粗粗一看，哇，好高大上的感觉，但是仔细看看类里面的内容，卧槽，这不就是原型对象里面的东西吗。。如果我们把<mred>_parent</mred>这个实例的原型打印出来，如下所示：\n```javascript\n{\n    constructor: class parent,\n    dosth: ƒ dosth(),\n    __proto__:Object\n}\n```\n是不是一目了然了，<mred>class</mred>里面定义的就是原型对象里面的属性而已，通过<mred>class</mred>关键字，我们可以在<mred>class</mred>里面一起定义原型属性和构造函数的自定义属性，这种方式相比较ES5的在构造函数里定义显的更加优雅和直观，通过类来new一个对象也就顺理成章，不会像ES5用构造函数来new一个对象那么生硬。\n\n接下来说说<mred>static</mred>关键字，这个很有意思，他可以隔离实例与原型对象的联系，换句话说，你用<mred>static</mred>定义的方法，并不能被实例所访问到，所以是静态的，而不是共有的，类似下面这样：\n```javascript\nclass parent {\n    constructor() {\n        this.name = 'redjue';\n        this.age = 24\n    }\n    static ifVisit() {\n        console.log('访问到了！')\n    }\n    dosth() {\n        console.log('做些事!')\n    }\n}\nvar _parent = new parent();\n_parent.ifVisit();//_parent.ifVisit is not a function\nparent.ifVisit();//访问到了！\n```\n这给我们在某些特定情况下不想让实例访问我们原型里定义的方法提供了方便，也更严谨了。\n\nES6提出了一种全新的继承方式，形式和<mred>java</mred>的继承看上去很像，通过<mred>extend</mred>关键字来实现：\n```javascript\nclass parent {\n    constructor() {\n        this.name = 'redjue';\n        this.age = 24\n    }\n    dosth() {\n        console.log('做些事!')\n    }\n}\nclass child extends parent {\n    constructor() {\n        super();\n        this.career = 'programmer'\n    }\n}\nvar _child = new child();//{name: \"redjue\", age: 24, career: \"programmer\"}\n_child.dosth();//做些事!\n```\n完美！既把父类的属性私有化了，又继承到了父类原型里的<mred>dosth</mred>方法，让我们把<mred>_child</mred>的原型输出来看看：\n```javascript\n{\n    constructor: class child,\n    __proto__: Object\n}\n```\n我们发现原型的<mred>constructor</mred>指向的是class child，那父类的属性是怎么跑到子类里的呢？，秘密就在<mred>super</mred>关键字。\n\n<mred>super</mred>关键字和我们之前探讨过的ES5继承里面的借用构造其实是一个意思，<mred>super</mred>是ES6向我们提供的语法糖而已，等价于ES5的<mred>parent.call(this)</mred>,区别在于ES6语法规定不用<mred>super</mred>关键字就没有<mred>this</mred>指向，所以不能直接替换用，只是底层原理是类似的：\n```javascript\n{\n   class child extends parent {\n    constructor() {\n        super();//类似于parent.call(this)\n        this.career = 'programmer'\n    }\n}\n}\n```\n### <mblack>ES6继承实现的原理</mblack>\nES6实现继承其实也就走了两条路，属性的私有化和方法的共有化，大致过程如下：\n```javascript\nclass child.__proto__=class parent;//属性私有化\nclass child.prototype.__proto__=class parent.prototype;//方法共有化\n```\nES5的组合继承根本上讲也就是为了实现以上两种情况，只不过ES6的实现更加优雅，还有一点值得指出来的是，ES5构造函数的`__proto__`永远指向的是<mred>Function</mred>对象的原型，不会因为实例的继承而改变指向，而在ES6中不一样，当子类继承父类之后，子类的`__proto__`会指向父类，这样表示显得更加规范，也清楚明了的表示了子类继承了父类的属性。\n#### 备注：本篇博客皆为博主原创，转发请标明出处。","source":"_posts/谈谈js的原型与继承.md","raw":"---\ntitle: 谈谈js的原型与继承\ndate: 2017-08-26 14:12:37\ntags: 原型与继承\n---\n![谈谈js的原型与继承](谈谈js的原型与继承/pic.jpg)\njavascript是一门弱类型的语言，所以并没有像java这种有类的概念，自然也没有子类继承父类这一说，但是所幸js有自己的一套继承机制，下面我就来谈谈关于js的继承我的一点微薄的理解。\n\n<!-- more -->\n\n## <mblue>构造函数</mblue>\njs创建对象的方式有很多，比如对象字面量直接创建啊，类似这样：\n```javascript\n//这种算是最简单的创建对象的方法，简单粗暴\nvar obj = new Object();//或者\nvar obj = {};\n```\n或者工厂模式创建，类似这样：\n```javascript\n//当你需要批量创建对象时可以用工厂模式统一创建\nfunction factory(name, age) {\n    var obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    obj.dosth = function () {\n        console.log('做些事!');\n    }\n    return obj;\n}\nvar example1 = factory('redjue', 24) // {name: \"redjue\", age: 24, dosth: ƒ}\n```\n亦或者构造函数模式创建，类似这样：\n```javascript\n//构造函数解决了工厂模式反复创建函数方法的弊端，减少了对象的体积\nfunction constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    constructor.prototype.dosth = function () {\n        console.log('做些事!');\n    }\n}\nvar example2 = new constructor('redjue', 24);//{name: \"redjue\", age: 24}\nexample2.dosth() //做些事! \n```\njs的新手看到构造函数这可能会比较迷。。对象里没有<mred>dosth</mred>这个方法，它怎么还能调用到？是被什么‘吃’了吗，事实上它确实被‘吃’了，它被<mred>constructor</mred>的原型对象给接管了，具体形式如下：\n```javascript\n//constructor.prototype\n{\n    dosth:function(){\n        console.log('做些事!'); \n    },\n    constructor:constructor(name, age){...},\n    __proto__:Object    \n}\n```\n那么为什么<mred>example2</mred>能调用到<mred>constructor</mred>原型对象里的方法呢，构造函数的原型对象与他实例化的对象之间是通过什么连接起来的呢？这就要提到另一个概念，原型链的传递。\n\n## <mblue>原型链的传递</mblue>\n### <mblack>构造函数创建实例的过程</mblack>\n构造函数通过<mred>new</mred>关键字来创建实例对象，具体过程如下：\n\n1. 创建一个空对象。\n2. 将构造函数的作用域赋值给这个空对象，也就是改变<mred>this</mred>指向。\n3. 根据构造函数中创建对象的代码，实例化这个空对象。\n4. 返回这个新对象。\n\n我们一步步来看，创建一个空对象就是直接通过对象字面量直接创建一个对象：\n```javascript\nvar newObj = new Object();\n```\n第二步中所做的，可以用以下代码表示：\n\n```javascript\n//让constructor构造函数在newObj的环境下执行，this自然指向newObj\nconstructor.call(newObj);\n//也可以形象的表示成这样\nnewObj = {\n    constructor: function (name, age) {\n        this.name = name;\n        this.age = age;\n        this.constructor.prototype.dosth = function () {\n            console.log('做些事!');\n        }\n    }\n}\n```\n第三步，如下：\n```javascript\n//当然constructor并没有在newObj里面，这段代码只是表示了和call函数做的一样的事\nnewObj.constructor('redjue', 24);\n```\n第四步，返回构造函数的实例：\n```javascript\nreturn newObj \n```\n至此，我们通过构造函数创建了一个实例对象，但是这个过程看起来似乎并没有关于原型链传递的操作对不对？其实嘛，js的底层都帮我们解决了，这里要介绍一个有关原型链传递的关键属性`__proto__`。\n\n### <mblack>proto属性</mblack>\n这个属性为什么能关乎原型链的传递呢？原因就在实例化对象的过程中，<mred>constructor</mred>把自己的原型对象当做一个属性值赋值给了<mred>newObj</mred>，\n而这个被赋值的属性就是`__proto__`，这是一个特殊的属性，专门用来保存指向对应原型的指针。所以当在调用实例对象自己本身没有的属性或方法时，通过这个属性的指向，我们可以去<mred>constructor</mred>的原型里面查找，这一过程称为原型链的传递。特别要注意的一点，这一过程只发生在实例对象与原型之间，而和<mred>constructor</mred>没什么关系。\n\n## <mblue>ES5继承的实现</mblue>\n为什么要说ES5继承呢，主要是ES6出了一个新特性class，通过更优雅的语法来实现继承，但本质上来说和ES5的继承方式是一样的，只不过是一个语法糖，后面再谈ES6继承的一些特性和实现原理。\n### <mblack>常规的实现方式</mblack>\n我们知道了原型链的传递是发生在实例对象和原型之间的，那么我们如果想要实现继承的话，就可以把它们连接起来，类似这样：\n```javascript\nfunction parent(){\n //父类\n this.name='parent';\n this.age=56;\n parent.prototype.dosth = function () {\n    console.log('做些事!');\n}   \n}\nfunction child(){\n //子类\n this.name='child';\n this.age=24;\n}\n\n//连接原型链\nchild.prototype=new parent();\nvar child=new child();\nchild.dosth() //'做些事!'\n```\n子类的实例对象可以通过搜索原型链往上找，最终找到父类原型里面的<mred>dosth</mred>方法。但是这样做有个问题，我们来看看子类的原型：\n```javascript\n//子类原型\n{\n    age: 56,\n    name: \"parent\",\n    __proto__: Object\n}\n```\n发现问题了吗，子类的原型就是父类的实例对象，意味着这个实例对象里面的属性其实是作为原型里的属性而存在的，这违背了属性私有化的理念，我们只是想把方法进行复用，而属性并不需要共有。\n### <mblack>借用构造实现组合继承</mblack>\n既然我们遇到了这个问题，那么有没有什么办法能解决这个问题？有大神用了一种巧妙的办法规避了这个问题，这就是借用构造函数：\n```javascript\nfunction parent() {\n    //父类\n    this.name = 'parent';\n    this.age = 56;\n    parent.prototype.dosth = function () {\n        console.log('做些事!');\n    }\n}\nfunction child() {\n    //子类\n    this.name = 'child';\n    this.age = 24;\n    //将父类的属性在子类中私有化\n    parent.call(this);\n}\n\n//连接原型链\nchild.prototype = new parent();\n//将child原型的constructor指向child自身，默认状态指向的是parent，显然有问题\nchild.prototype.constructor=child;\nvar _child = new child();\n_child.dosth() //'做些事!'\n```\n这样我们保证了，<mred>child</mred>的每个实例对象都有<mred>parent</mred>定义的私有属性，而不是共享<mred>_child</mred>继承的<mred>parent</mred>的实例里面的共有属性，实现了属性私有，方法复用的比较完美的组合继承。\n\n## <mblue>ES6继承的实现</mblue>\n### <mblack>class，static，extend和super关键字</mblack>\nES6引入了一个新的概念<mred>class</mred>，也就是类，形式类似这样：\n```javascript\nclass parent {\n    constructor() {\n        this.name = 'redjue';\n        this.age = 24\n    }\n    dosth() {\n        console.log('做些事!')\n    }\n}\nvar _parent = new parent;//{name: \"redjue\", age: 24}\n```\n粗粗一看，哇，好高大上的感觉，但是仔细看看类里面的内容，卧槽，这不就是原型对象里面的东西吗。。如果我们把<mred>_parent</mred>这个实例的原型打印出来，如下所示：\n```javascript\n{\n    constructor: class parent,\n    dosth: ƒ dosth(),\n    __proto__:Object\n}\n```\n是不是一目了然了，<mred>class</mred>里面定义的就是原型对象里面的属性而已，通过<mred>class</mred>关键字，我们可以在<mred>class</mred>里面一起定义原型属性和构造函数的自定义属性，这种方式相比较ES5的在构造函数里定义显的更加优雅和直观，通过类来new一个对象也就顺理成章，不会像ES5用构造函数来new一个对象那么生硬。\n\n接下来说说<mred>static</mred>关键字，这个很有意思，他可以隔离实例与原型对象的联系，换句话说，你用<mred>static</mred>定义的方法，并不能被实例所访问到，所以是静态的，而不是共有的，类似下面这样：\n```javascript\nclass parent {\n    constructor() {\n        this.name = 'redjue';\n        this.age = 24\n    }\n    static ifVisit() {\n        console.log('访问到了！')\n    }\n    dosth() {\n        console.log('做些事!')\n    }\n}\nvar _parent = new parent();\n_parent.ifVisit();//_parent.ifVisit is not a function\nparent.ifVisit();//访问到了！\n```\n这给我们在某些特定情况下不想让实例访问我们原型里定义的方法提供了方便，也更严谨了。\n\nES6提出了一种全新的继承方式，形式和<mred>java</mred>的继承看上去很像，通过<mred>extend</mred>关键字来实现：\n```javascript\nclass parent {\n    constructor() {\n        this.name = 'redjue';\n        this.age = 24\n    }\n    dosth() {\n        console.log('做些事!')\n    }\n}\nclass child extends parent {\n    constructor() {\n        super();\n        this.career = 'programmer'\n    }\n}\nvar _child = new child();//{name: \"redjue\", age: 24, career: \"programmer\"}\n_child.dosth();//做些事!\n```\n完美！既把父类的属性私有化了，又继承到了父类原型里的<mred>dosth</mred>方法，让我们把<mred>_child</mred>的原型输出来看看：\n```javascript\n{\n    constructor: class child,\n    __proto__: Object\n}\n```\n我们发现原型的<mred>constructor</mred>指向的是class child，那父类的属性是怎么跑到子类里的呢？，秘密就在<mred>super</mred>关键字。\n\n<mred>super</mred>关键字和我们之前探讨过的ES5继承里面的借用构造其实是一个意思，<mred>super</mred>是ES6向我们提供的语法糖而已，等价于ES5的<mred>parent.call(this)</mred>,区别在于ES6语法规定不用<mred>super</mred>关键字就没有<mred>this</mred>指向，所以不能直接替换用，只是底层原理是类似的：\n```javascript\n{\n   class child extends parent {\n    constructor() {\n        super();//类似于parent.call(this)\n        this.career = 'programmer'\n    }\n}\n}\n```\n### <mblack>ES6继承实现的原理</mblack>\nES6实现继承其实也就走了两条路，属性的私有化和方法的共有化，大致过程如下：\n```javascript\nclass child.__proto__=class parent;//属性私有化\nclass child.prototype.__proto__=class parent.prototype;//方法共有化\n```\nES5的组合继承根本上讲也就是为了实现以上两种情况，只不过ES6的实现更加优雅，还有一点值得指出来的是，ES5构造函数的`__proto__`永远指向的是<mred>Function</mred>对象的原型，不会因为实例的继承而改变指向，而在ES6中不一样，当子类继承父类之后，子类的`__proto__`会指向父类，这样表示显得更加规范，也清楚明了的表示了子类继承了父类的属性。\n#### 备注：本篇博客皆为博主原创，转发请标明出处。","slug":"谈谈js的原型与继承","published":1,"updated":"2020-01-07T02:31:54.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck53b1upg000c0vk52kv08283","content":"<p><img src=\"/2017/08/26/谈谈js的原型与继承/pic.jpg\" alt=\"谈谈js的原型与继承\"><br>javascript是一门弱类型的语言，所以并没有像java这种有类的概念，自然也没有子类继承父类这一说，但是所幸js有自己的一套继承机制，下面我就来谈谈关于js的继承我的一点微薄的理解。</p>\n<a id=\"more\"></a>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a><mblue>构造函数</mblue></h2><p>js创建对象的方式有很多，比如对象字面量直接创建啊，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这种算是最简单的创建对象的方法，简单粗暴</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();<span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>或者工厂模式创建，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当你需要批量创建对象时可以用工厂模式统一创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factory</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    obj.name = name;</span><br><span class=\"line\">    obj.age = age;</span><br><span class=\"line\">    obj.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> example1 = factory(<span class=\"string\">'redjue'</span>, <span class=\"number\">24</span>) <span class=\"comment\">// &#123;name: \"redjue\", age: 24, dosth: ƒ&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>亦或者构造函数模式创建，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数解决了工厂模式反复创建函数方法的弊端，减少了对象的体积</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructor</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>.prototype.dosth = function () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> <span class=\"keyword\">constructor</span>('redjue', 24);//&#123;name: <span class=\"string\">\"redjue\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;</span><br><span class=\"line\">example2.dosth() <span class=\"comment\">//做些事!</span></span><br></pre></td></tr></table></figure></p>\n<p>js的新手看到构造函数这可能会比较迷。。对象里没有<mred>dosth</mred>这个方法，它怎么还能调用到？是被什么‘吃’了吗，事实上它确实被‘吃’了，它被<mred>constructor</mred>的原型对象给接管了，具体形式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//constructor.prototype</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dosth:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>); </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>:<span class=\"keyword\">constructor</span>(name, age)&#123;...&#125;,</span><br><span class=\"line\">    __proto__:<span class=\"built_in\">Object</span>    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么为什么<mred>example2</mred>能调用到<mred>constructor</mred>原型对象里的方法呢，构造函数的原型对象与他实例化的对象之间是通过什么连接起来的呢？这就要提到另一个概念，原型链的传递。</p>\n<h2 id=\"原型链的传递\"><a href=\"#原型链的传递\" class=\"headerlink\" title=\"原型链的传递\"></a><mblue>原型链的传递</mblue></h2><h3 id=\"构造函数创建实例的过程\"><a href=\"#构造函数创建实例的过程\" class=\"headerlink\" title=\"构造函数创建实例的过程\"></a><mblack>构造函数创建实例的过程</mblack></h3><p>构造函数通过<mred>new</mred>关键字来创建实例对象，具体过程如下：</p>\n<ol>\n<li>创建一个空对象。</li>\n<li>将构造函数的作用域赋值给这个空对象，也就是改变<mred>this</mred>指向。</li>\n<li>根据构造函数中创建对象的代码，实例化这个空对象。</li>\n<li>返回这个新对象。</li>\n</ol>\n<p>我们一步步来看，创建一个空对象就是直接通过对象字面量直接创建一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure></p>\n<p>第二步中所做的，可以用以下代码表示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让constructor构造函数在newObj的环境下执行，this自然指向newObj</span></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>.call(newObj);</span><br><span class=\"line\">//也可以形象的表示成这样</span><br><span class=\"line\">newObj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: function (name, age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.constructor.prototype.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当然constructor并没有在newObj里面，这段代码只是表示了和call函数做的一样的事</span></span><br><span class=\"line\">newObj.constructor(<span class=\"string\">'redjue'</span>, <span class=\"number\">24</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第四步，返回构造函数的实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> newObj</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们通过构造函数创建了一个实例对象，但是这个过程看起来似乎并没有关于原型链传递的操作对不对？其实嘛，js的底层都帮我们解决了，这里要介绍一个有关原型链传递的关键属性<code>__proto__</code>。</p>\n<h3 id=\"proto属性\"><a href=\"#proto属性\" class=\"headerlink\" title=\"proto属性\"></a><mblack>proto属性</mblack></h3><p>这个属性为什么能关乎原型链的传递呢？原因就在实例化对象的过程中，<mred>constructor</mred>把自己的原型对象当做一个属性值赋值给了<mred>newObj</mred>，<br>而这个被赋值的属性就是<code>__proto__</code>，这是一个特殊的属性，专门用来保存指向对应原型的指针。所以当在调用实例对象自己本身没有的属性或方法时，通过这个属性的指向，我们可以去<mred>constructor</mred>的原型里面查找，这一过程称为原型链的传递。特别要注意的一点，这一过程只发生在实例对象与原型之间，而和<mred>constructor</mred>没什么关系。</p>\n<h2 id=\"ES5继承的实现\"><a href=\"#ES5继承的实现\" class=\"headerlink\" title=\"ES5继承的实现\"></a><mblue>ES5继承的实现</mblue></h2><p>为什么要说ES5继承呢，主要是ES6出了一个新特性class，通过更优雅的语法来实现继承，但本质上来说和ES5的继承方式是一样的，只不过是一个语法糖，后面再谈ES6继承的一些特性和实现原理。</p>\n<h3 id=\"常规的实现方式\"><a href=\"#常规的实现方式\" class=\"headerlink\" title=\"常规的实现方式\"></a><mblack>常规的实现方式</mblack></h3><p>我们知道了原型链的传递是发生在实例对象和原型之间的，那么我们如果想要实现继承的话，就可以把它们连接起来，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//父类</span></span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name=<span class=\"string\">'parent'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.age=<span class=\"number\">56</span>;</span><br><span class=\"line\"> parent.prototype.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//子类</span></span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name=<span class=\"string\">'child'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.age=<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//连接原型链</span></span><br><span class=\"line\">child.prototype=<span class=\"keyword\">new</span> parent();</span><br><span class=\"line\"><span class=\"keyword\">var</span> child=<span class=\"keyword\">new</span> child();</span><br><span class=\"line\">child.dosth() <span class=\"comment\">//'做些事!'</span></span><br></pre></td></tr></table></figure></p>\n<p>子类的实例对象可以通过搜索原型链往上找，最终找到父类原型里面的<mred>dosth</mred>方法。但是这样做有个问题，我们来看看子类的原型：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类原型</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    age: <span class=\"number\">56</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"parent\"</span>,</span><br><span class=\"line\">    __proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>发现问题了吗，子类的原型就是父类的实例对象，意味着这个实例对象里面的属性其实是作为原型里的属性而存在的，这违背了属性私有化的理念，我们只是想把方法进行复用，而属性并不需要共有。</p>\n<h3 id=\"借用构造实现组合继承\"><a href=\"#借用构造实现组合继承\" class=\"headerlink\" title=\"借用构造实现组合继承\"></a><mblack>借用构造实现组合继承</mblack></h3><p>既然我们遇到了这个问题，那么有没有什么办法能解决这个问题？有大神用了一种巧妙的办法规避了这个问题，这就是借用构造函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//父类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'parent'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">56</span>;</span><br><span class=\"line\">    parent.prototype.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//子类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'child'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span>;</span><br><span class=\"line\">    <span class=\"comment\">//将父类的属性在子类中私有化</span></span><br><span class=\"line\">    parent.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//连接原型链</span></span><br><span class=\"line\">child.prototype = <span class=\"keyword\">new</span> parent();</span><br><span class=\"line\"><span class=\"comment\">//将child原型的constructor指向child自身，默认状态指向的是parent，显然有问题</span></span><br><span class=\"line\">child.prototype.constructor=child;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _child = <span class=\"keyword\">new</span> child();</span><br><span class=\"line\">_child.dosth() <span class=\"comment\">//'做些事!'</span></span><br></pre></td></tr></table></figure></p>\n<p>这样我们保证了，<mred>child</mred>的每个实例对象都有<mred>parent</mred>定义的私有属性，而不是共享<mred>_child</mred>继承的<mred>parent</mred>的实例里面的共有属性，实现了属性私有，方法复用的比较完美的组合继承。</p>\n<h2 id=\"ES6继承的实现\"><a href=\"#ES6继承的实现\" class=\"headerlink\" title=\"ES6继承的实现\"></a><mblue>ES6继承的实现</mblue></h2><h3 id=\"class，static，extend和super关键字\"><a href=\"#class，static，extend和super关键字\" class=\"headerlink\" title=\"class，static，extend和super关键字\"></a><mblack>class，static，extend和super关键字</mblack></h3><p>ES6引入了一个新的概念<mred>class</mred>，也就是类，形式类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'redjue'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dosth() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _parent = <span class=\"keyword\">new</span> parent;<span class=\"comment\">//&#123;name: \"redjue\", age: 24&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>粗粗一看，哇，好高大上的感觉，但是仔细看看类里面的内容，卧槽，这不就是原型对象里面的东西吗。。如果我们把<mred>_parent</mred>这个实例的原型打印出来，如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: class parent,</span><br><span class=\"line\">    dosth: ƒ dosth(),</span><br><span class=\"line\">    __proto__:Object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>是不是一目了然了，<mred>class</mred>里面定义的就是原型对象里面的属性而已，通过<mred>class</mred>关键字，我们可以在<mred>class</mred>里面一起定义原型属性和构造函数的自定义属性，这种方式相比较ES5的在构造函数里定义显的更加优雅和直观，通过类来new一个对象也就顺理成章，不会像ES5用构造函数来new一个对象那么生硬。</p>\n<p>接下来说说<mred>static</mred>关键字，这个很有意思，他可以隔离实例与原型对象的联系，换句话说，你用<mred>static</mred>定义的方法，并不能被实例所访问到，所以是静态的，而不是共有的，类似下面这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'redjue'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ifVisit() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'访问到了！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dosth() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _parent = <span class=\"keyword\">new</span> parent();</span><br><span class=\"line\">_parent.ifVisit();<span class=\"comment\">//_parent.ifVisit is not a function</span></span><br><span class=\"line\">parent.ifVisit();<span class=\"comment\">//访问到了！</span></span><br></pre></td></tr></table></figure></p>\n<p>这给我们在某些特定情况下不想让实例访问我们原型里定义的方法提供了方便，也更严谨了。</p>\n<p>ES6提出了一种全新的继承方式，形式和<mred>java</mred>的继承看上去很像，通过<mred>extend</mred>关键字来实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'redjue'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dosth() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span> <span class=\"keyword\">extends</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.career = <span class=\"string\">'programmer'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _child = <span class=\"keyword\">new</span> child();<span class=\"comment\">//&#123;name: \"redjue\", age: 24, career: \"programmer\"&#125;</span></span><br><span class=\"line\">_child.dosth();<span class=\"comment\">//做些事!</span></span><br></pre></td></tr></table></figure></p>\n<p>完美！既把父类的属性私有化了，又继承到了父类原型里的<mred>dosth</mred>方法，让我们把<mred>_child</mred>的原型输出来看看：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: class child,</span><br><span class=\"line\">    __proto__: Object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们发现原型的<mred>constructor</mred>指向的是class child，那父类的属性是怎么跑到子类里的呢？，秘密就在<mred>super</mred>关键字。</p>\n<p><mred>super</mred>关键字和我们之前探讨过的ES5继承里面的借用构造其实是一个意思，<mred>super</mred>是ES6向我们提供的语法糖而已，等价于ES5的<mred>parent.call(this)</mred>,区别在于ES6语法规定不用<mred>super</mred>关键字就没有<mred>this</mred>指向，所以不能直接替换用，只是底层原理是类似的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span> <span class=\"keyword\">extends</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();<span class=\"comment\">//类似于parent.call(this)</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.career = <span class=\"string\">'programmer'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ES6继承实现的原理\"><a href=\"#ES6继承实现的原理\" class=\"headerlink\" title=\"ES6继承实现的原理\"></a><mblack>ES6继承实现的原理</mblack></h3><p>ES6实现继承其实也就走了两条路，属性的私有化和方法的共有化，大致过程如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span>.<span class=\"title\">__proto__</span></span>=<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span></span>;<span class=\"comment\">//属性私有化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span>.<span class=\"title\">prototype</span>.<span class=\"title\">__proto__</span></span>=<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span>.<span class=\"title\">prototype</span></span>;<span class=\"comment\">//方法共有化</span></span><br></pre></td></tr></table></figure></p>\n<p>ES5的组合继承根本上讲也就是为了实现以上两种情况，只不过ES6的实现更加优雅，还有一点值得指出来的是，ES5构造函数的<code>__proto__</code>永远指向的是<mred>Function</mred>对象的原型，不会因为实例的继承而改变指向，而在ES6中不一样，当子类继承父类之后，子类的<code>__proto__</code>会指向父类，这样表示显得更加规范，也清楚明了的表示了子类继承了父类的属性。</p>\n<h4 id=\"备注：本篇博客皆为博主原创，转发请标明出处。\"><a href=\"#备注：本篇博客皆为博主原创，转发请标明出处。\" class=\"headerlink\" title=\"备注：本篇博客皆为博主原创，转发请标明出处。\"></a>备注：本篇博客皆为博主原创，转发请标明出处。</h4>","site":{"data":{}},"excerpt":"<p><img src=\"/2017/08/26/谈谈js的原型与继承/pic.jpg\" alt=\"谈谈js的原型与继承\"><br>javascript是一门弱类型的语言，所以并没有像java这种有类的概念，自然也没有子类继承父类这一说，但是所幸js有自己的一套继承机制，下面我就来谈谈关于js的继承我的一点微薄的理解。</p>","more":"<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a><mblue>构造函数</mblue></h2><p>js创建对象的方式有很多，比如对象字面量直接创建啊，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这种算是最简单的创建对象的方法，简单粗暴</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();<span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>或者工厂模式创建，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当你需要批量创建对象时可以用工厂模式统一创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factory</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    obj.name = name;</span><br><span class=\"line\">    obj.age = age;</span><br><span class=\"line\">    obj.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> example1 = factory(<span class=\"string\">'redjue'</span>, <span class=\"number\">24</span>) <span class=\"comment\">// &#123;name: \"redjue\", age: 24, dosth: ƒ&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>亦或者构造函数模式创建，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数解决了工厂模式反复创建函数方法的弊端，减少了对象的体积</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructor</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>.prototype.dosth = function () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> <span class=\"keyword\">constructor</span>('redjue', 24);//&#123;name: <span class=\"string\">\"redjue\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;</span><br><span class=\"line\">example2.dosth() <span class=\"comment\">//做些事!</span></span><br></pre></td></tr></table></figure></p>\n<p>js的新手看到构造函数这可能会比较迷。。对象里没有<mred>dosth</mred>这个方法，它怎么还能调用到？是被什么‘吃’了吗，事实上它确实被‘吃’了，它被<mred>constructor</mred>的原型对象给接管了，具体形式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//constructor.prototype</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dosth:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>); </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>:<span class=\"keyword\">constructor</span>(name, age)&#123;...&#125;,</span><br><span class=\"line\">    __proto__:<span class=\"built_in\">Object</span>    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么为什么<mred>example2</mred>能调用到<mred>constructor</mred>原型对象里的方法呢，构造函数的原型对象与他实例化的对象之间是通过什么连接起来的呢？这就要提到另一个概念，原型链的传递。</p>\n<h2 id=\"原型链的传递\"><a href=\"#原型链的传递\" class=\"headerlink\" title=\"原型链的传递\"></a><mblue>原型链的传递</mblue></h2><h3 id=\"构造函数创建实例的过程\"><a href=\"#构造函数创建实例的过程\" class=\"headerlink\" title=\"构造函数创建实例的过程\"></a><mblack>构造函数创建实例的过程</mblack></h3><p>构造函数通过<mred>new</mred>关键字来创建实例对象，具体过程如下：</p>\n<ol>\n<li>创建一个空对象。</li>\n<li>将构造函数的作用域赋值给这个空对象，也就是改变<mred>this</mred>指向。</li>\n<li>根据构造函数中创建对象的代码，实例化这个空对象。</li>\n<li>返回这个新对象。</li>\n</ol>\n<p>我们一步步来看，创建一个空对象就是直接通过对象字面量直接创建一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure></p>\n<p>第二步中所做的，可以用以下代码表示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让constructor构造函数在newObj的环境下执行，this自然指向newObj</span></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>.call(newObj);</span><br><span class=\"line\">//也可以形象的表示成这样</span><br><span class=\"line\">newObj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: function (name, age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.constructor.prototype.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当然constructor并没有在newObj里面，这段代码只是表示了和call函数做的一样的事</span></span><br><span class=\"line\">newObj.constructor(<span class=\"string\">'redjue'</span>, <span class=\"number\">24</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第四步，返回构造函数的实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> newObj</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们通过构造函数创建了一个实例对象，但是这个过程看起来似乎并没有关于原型链传递的操作对不对？其实嘛，js的底层都帮我们解决了，这里要介绍一个有关原型链传递的关键属性<code>__proto__</code>。</p>\n<h3 id=\"proto属性\"><a href=\"#proto属性\" class=\"headerlink\" title=\"proto属性\"></a><mblack>proto属性</mblack></h3><p>这个属性为什么能关乎原型链的传递呢？原因就在实例化对象的过程中，<mred>constructor</mred>把自己的原型对象当做一个属性值赋值给了<mred>newObj</mred>，<br>而这个被赋值的属性就是<code>__proto__</code>，这是一个特殊的属性，专门用来保存指向对应原型的指针。所以当在调用实例对象自己本身没有的属性或方法时，通过这个属性的指向，我们可以去<mred>constructor</mred>的原型里面查找，这一过程称为原型链的传递。特别要注意的一点，这一过程只发生在实例对象与原型之间，而和<mred>constructor</mred>没什么关系。</p>\n<h2 id=\"ES5继承的实现\"><a href=\"#ES5继承的实现\" class=\"headerlink\" title=\"ES5继承的实现\"></a><mblue>ES5继承的实现</mblue></h2><p>为什么要说ES5继承呢，主要是ES6出了一个新特性class，通过更优雅的语法来实现继承，但本质上来说和ES5的继承方式是一样的，只不过是一个语法糖，后面再谈ES6继承的一些特性和实现原理。</p>\n<h3 id=\"常规的实现方式\"><a href=\"#常规的实现方式\" class=\"headerlink\" title=\"常规的实现方式\"></a><mblack>常规的实现方式</mblack></h3><p>我们知道了原型链的传递是发生在实例对象和原型之间的，那么我们如果想要实现继承的话，就可以把它们连接起来，类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//父类</span></span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name=<span class=\"string\">'parent'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.age=<span class=\"number\">56</span>;</span><br><span class=\"line\"> parent.prototype.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//子类</span></span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name=<span class=\"string\">'child'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.age=<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//连接原型链</span></span><br><span class=\"line\">child.prototype=<span class=\"keyword\">new</span> parent();</span><br><span class=\"line\"><span class=\"keyword\">var</span> child=<span class=\"keyword\">new</span> child();</span><br><span class=\"line\">child.dosth() <span class=\"comment\">//'做些事!'</span></span><br></pre></td></tr></table></figure></p>\n<p>子类的实例对象可以通过搜索原型链往上找，最终找到父类原型里面的<mred>dosth</mred>方法。但是这样做有个问题，我们来看看子类的原型：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子类原型</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    age: <span class=\"number\">56</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"parent\"</span>,</span><br><span class=\"line\">    __proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>发现问题了吗，子类的原型就是父类的实例对象，意味着这个实例对象里面的属性其实是作为原型里的属性而存在的，这违背了属性私有化的理念，我们只是想把方法进行复用，而属性并不需要共有。</p>\n<h3 id=\"借用构造实现组合继承\"><a href=\"#借用构造实现组合继承\" class=\"headerlink\" title=\"借用构造实现组合继承\"></a><mblack>借用构造实现组合继承</mblack></h3><p>既然我们遇到了这个问题，那么有没有什么办法能解决这个问题？有大神用了一种巧妙的办法规避了这个问题，这就是借用构造函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//父类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'parent'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">56</span>;</span><br><span class=\"line\">    parent.prototype.dosth = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//子类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'child'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span>;</span><br><span class=\"line\">    <span class=\"comment\">//将父类的属性在子类中私有化</span></span><br><span class=\"line\">    parent.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//连接原型链</span></span><br><span class=\"line\">child.prototype = <span class=\"keyword\">new</span> parent();</span><br><span class=\"line\"><span class=\"comment\">//将child原型的constructor指向child自身，默认状态指向的是parent，显然有问题</span></span><br><span class=\"line\">child.prototype.constructor=child;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _child = <span class=\"keyword\">new</span> child();</span><br><span class=\"line\">_child.dosth() <span class=\"comment\">//'做些事!'</span></span><br></pre></td></tr></table></figure></p>\n<p>这样我们保证了，<mred>child</mred>的每个实例对象都有<mred>parent</mred>定义的私有属性，而不是共享<mred>_child</mred>继承的<mred>parent</mred>的实例里面的共有属性，实现了属性私有，方法复用的比较完美的组合继承。</p>\n<h2 id=\"ES6继承的实现\"><a href=\"#ES6继承的实现\" class=\"headerlink\" title=\"ES6继承的实现\"></a><mblue>ES6继承的实现</mblue></h2><h3 id=\"class，static，extend和super关键字\"><a href=\"#class，static，extend和super关键字\" class=\"headerlink\" title=\"class，static，extend和super关键字\"></a><mblack>class，static，extend和super关键字</mblack></h3><p>ES6引入了一个新的概念<mred>class</mred>，也就是类，形式类似这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'redjue'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dosth() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _parent = <span class=\"keyword\">new</span> parent;<span class=\"comment\">//&#123;name: \"redjue\", age: 24&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>粗粗一看，哇，好高大上的感觉，但是仔细看看类里面的内容，卧槽，这不就是原型对象里面的东西吗。。如果我们把<mred>_parent</mred>这个实例的原型打印出来，如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: class parent,</span><br><span class=\"line\">    dosth: ƒ dosth(),</span><br><span class=\"line\">    __proto__:Object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>是不是一目了然了，<mred>class</mred>里面定义的就是原型对象里面的属性而已，通过<mred>class</mred>关键字，我们可以在<mred>class</mred>里面一起定义原型属性和构造函数的自定义属性，这种方式相比较ES5的在构造函数里定义显的更加优雅和直观，通过类来new一个对象也就顺理成章，不会像ES5用构造函数来new一个对象那么生硬。</p>\n<p>接下来说说<mred>static</mred>关键字，这个很有意思，他可以隔离实例与原型对象的联系，换句话说，你用<mred>static</mred>定义的方法，并不能被实例所访问到，所以是静态的，而不是共有的，类似下面这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'redjue'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ifVisit() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'访问到了！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dosth() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _parent = <span class=\"keyword\">new</span> parent();</span><br><span class=\"line\">_parent.ifVisit();<span class=\"comment\">//_parent.ifVisit is not a function</span></span><br><span class=\"line\">parent.ifVisit();<span class=\"comment\">//访问到了！</span></span><br></pre></td></tr></table></figure></p>\n<p>这给我们在某些特定情况下不想让实例访问我们原型里定义的方法提供了方便，也更严谨了。</p>\n<p>ES6提出了一种全新的继承方式，形式和<mred>java</mred>的继承看上去很像，通过<mred>extend</mred>关键字来实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'redjue'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = <span class=\"number\">24</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dosth() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'做些事!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span> <span class=\"keyword\">extends</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.career = <span class=\"string\">'programmer'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _child = <span class=\"keyword\">new</span> child();<span class=\"comment\">//&#123;name: \"redjue\", age: 24, career: \"programmer\"&#125;</span></span><br><span class=\"line\">_child.dosth();<span class=\"comment\">//做些事!</span></span><br></pre></td></tr></table></figure></p>\n<p>完美！既把父类的属性私有化了，又继承到了父类原型里的<mred>dosth</mred>方法，让我们把<mred>_child</mred>的原型输出来看看：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: class child,</span><br><span class=\"line\">    __proto__: Object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们发现原型的<mred>constructor</mred>指向的是class child，那父类的属性是怎么跑到子类里的呢？，秘密就在<mred>super</mred>关键字。</p>\n<p><mred>super</mred>关键字和我们之前探讨过的ES5继承里面的借用构造其实是一个意思，<mred>super</mred>是ES6向我们提供的语法糖而已，等价于ES5的<mred>parent.call(this)</mred>,区别在于ES6语法规定不用<mred>super</mred>关键字就没有<mred>this</mred>指向，所以不能直接替换用，只是底层原理是类似的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span> <span class=\"keyword\">extends</span> <span class=\"title\">parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();<span class=\"comment\">//类似于parent.call(this)</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.career = <span class=\"string\">'programmer'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ES6继承实现的原理\"><a href=\"#ES6继承实现的原理\" class=\"headerlink\" title=\"ES6继承实现的原理\"></a><mblack>ES6继承实现的原理</mblack></h3><p>ES6实现继承其实也就走了两条路，属性的私有化和方法的共有化，大致过程如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span>.<span class=\"title\">__proto__</span></span>=<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span></span>;<span class=\"comment\">//属性私有化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">child</span>.<span class=\"title\">prototype</span>.<span class=\"title\">__proto__</span></span>=<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">parent</span>.<span class=\"title\">prototype</span></span>;<span class=\"comment\">//方法共有化</span></span><br></pre></td></tr></table></figure></p>\n<p>ES5的组合继承根本上讲也就是为了实现以上两种情况，只不过ES6的实现更加优雅，还有一点值得指出来的是，ES5构造函数的<code>__proto__</code>永远指向的是<mred>Function</mred>对象的原型，不会因为实例的继承而改变指向，而在ES6中不一样，当子类继承父类之后，子类的<code>__proto__</code>会指向父类，这样表示显得更加规范，也清楚明了的表示了子类继承了父类的属性。</p>\n<h4 id=\"备注：本篇博客皆为博主原创，转发请标明出处。\"><a href=\"#备注：本篇博客皆为博主原创，转发请标明出处。\" class=\"headerlink\" title=\"备注：本篇博客皆为博主原创，转发请标明出处。\"></a>备注：本篇博客皆为博主原创，转发请标明出处。</h4>"}],"PostAsset":[{"_id":"source/_posts/webpack常用插件整理/timg.jpg","post":"ck53b1up000000vk5qyfsedlq","slug":"timg.jpg","modified":1,"renderable":1},{"_id":"source/_posts/工作中遇到的bug整理/bug.jpg","post":"ck53b1upa00030vk5dy2m76fl","slug":"bug.jpg","modified":1,"renderable":1},{"_id":"source/_posts/浅谈浏览器加载优化/render_dom.png","post":"ck53b1upb00040vk5wir0dr7b","slug":"render_dom.png","modified":1,"renderable":1},{"_id":"source/_posts/谈谈js的原型与继承/pic.jpg","post":"ck53b1upg000c0vk52kv08283","slug":"pic.jpg","modified":1,"renderable":1},{"_id":"source/_posts/webpack的配置解析/error.png","post":"ck53b1up500010vk5tnvbzju0","slug":"error.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack的配置解析/success.png","post":"ck53b1up500010vk5tnvbzju0","slug":"success.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack的配置解析/webpack.jpg","post":"ck53b1up500010vk5tnvbzju0","slug":"webpack.jpg","modified":1,"renderable":1},{"_id":"source/_posts/webpack的配置解析/work.png","post":"ck53b1up500010vk5tnvbzju0","slug":"work.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"ck53b1up000000vk5qyfsedlq","tag_id":"ck53b1up800020vk5ipssx04j","_id":"ck53b1upd00060vk5mdezy0rn"},{"post_id":"ck53b1up500010vk5tnvbzju0","tag_id":"ck53b1upd00050vk5a3r6rtco","_id":"ck53b1upe00080vk5eny3yg60"},{"post_id":"ck53b1upa00030vk5dy2m76fl","tag_id":"ck53b1upd00070vk59ea7tp2u","_id":"ck53b1upe000a0vk5s4fp4rmr"},{"post_id":"ck53b1upb00040vk5wir0dr7b","tag_id":"ck53b1upe00090vk5knojoye8","_id":"ck53b1upe000b0vk584dvy9vq"},{"post_id":"ck53b1upg000c0vk52kv08283","tag_id":"ck53b1upj000f0vk5yatblpun","_id":"ck53b1upk000g0vk58svng1km"}],"Tag":[{"name":"webpack plugin","_id":"ck53b1up800020vk5ipssx04j"},{"name":"webpack","_id":"ck53b1upd00050vk5a3r6rtco"},{"name":"bugs","_id":"ck53b1upd00070vk59ea7tp2u"},{"name":"浏览器加载优化","_id":"ck53b1upe00090vk5knojoye8"},{"name":"原型与继承","_id":"ck53b1upj000f0vk5yatblpun"}]}}